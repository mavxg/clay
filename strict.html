<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<meta http-equiv="Content-Type" content="application/xhtml+xml">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title></title>
<link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,700|Inconsolata" />
<link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.5.0/pure-min.css"/>

<!--[if lte IE 8]>
    <link rel="stylesheet" href="css/layouts/side-menu-old-ie.css">
<![endif]-->
<!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="css/layouts/side-menu.css">
<!--<![endif]-->
<link rel="stylesheet" href="css/clay.css"/>
<style type="text/css">
/* stuff here */

figcaption {
	position: absolute;
	top: 0;
	left: -170px;
	width: 150px;
	font-style: italic;
	text-align: right;
	color: rgba(0,0,0,0.5);
	font-family: serif;
}
figcaption:before {
	width: 35%;
	margin-left: 65%;
	border-top: 1px solid #edece4;
	display: block;
	content: '';
	margin-bottom: 5px;
}
figure {
	position: relative;
	clear: both;
}
hr {
	border-top: 1px solid #edece4;
	border-bottom: 0;
	border-left: 0;
	border-right: 0;
}
</style>
</head>
<body>
<div id="layout">
    <!-- Menu toggle -->

    <div id="main">
	</div>
</div>
<script type="text/javascript">

var main = document.getElementById('main')

var parsers = {
	'#': function(l) {
		var level = /^#+/.exec(l)[0].length;
		return {type: 'header', level: level, raw: l, text: l.slice(level)};
	},
	p: function(l) {
		//TODO: spans
		return {type: 'p', raw: l, spans: (l.length > 0 ? [{type: 'text', text: l}] : [])};
	},
	'!': function(l) {
		if (sub = /^!\[([^\]]*)\]\(([^\)]*)\)(.*)/.exec(l)) {
			return {type: 'figure', alt: sub[1], src: sub[2], caption: sub[3], raw:l};
		}
		return parsers.p(l);
	},
	' ': function(l) { 
		return {type: 'code', raw: l, text: l.slice(1) + '\n'};
	},
	'*': function(l) { 
		return {type: 'ulli', raw: l, spans: [{type: 'text', text: l.slice(1)}]};
	},
	'.': function(l) { 
		return {type: 'olli', raw: l, spans: [{type: 'text', text: l.slice(1)}]};
	},
	'>': function(l) { 
		return {type: 'quote', raw: l, spans: [{type: 'text', text: l.slice(1)}]}; 
	},
	'%': function(l) { 
		return {type: 'meta', raw: l, text: l.slice(1)}; 
	},
	'-': function(l) {
		if (l.length === 1) return {type: 'break', raw: l};
		return parsers.p(l);
	},
	'|': function(l) {
		return {type: 'tr', raw: l, values: l.slice(1).split('|')};
	},
}

function parse(text) {
	return text.split('\n').map(function(l,i) {
		var cap;
		if (cap = /^[\#\!\% \*\.\>\-\|]/.exec(l)) {
			if (parsers.hasOwnProperty(cap[0])) return parsers[cap[0]](l);
		}
		return parsers.p(l);
	});
}

function gatherAll(tag) {
	return function(items) {
		var elm = document.createElement(tag);
		items.forEach(function(el,i) {
			elm.appendChild(renderers[el.type](el));
		});
		return elm;
	};
}

var gatherers = {
	ulli: gatherAll('ul'),
	olli: gatherAll('ol'),
	code: gatherAll('pre'), //TODO: replace to return a result element (document fragment)
	tr: function(items) {
		var thead = document.createElement('thead');
		var tbody = document.createElement('tbody');
		var table = document.createElement('table');
		table.className = 'pure-table pure-table-bordered';
		table.appendChild(thead);
		table.appendChild(tbody);
		items.forEach(function(tr, i) {
			if (i == 0) thead.appendChild(renderers.thr(tr));
			else tbody.appendChild(renderers.tr(tr));
		});
		return table;
	},
};

function renderSpan(tag) {
	return function(item) {
		var para = document.createElement(tag);
		if (item.spans.length === 0) para.appendChild(document.createElement('br'));
		item.spans.forEach(function(c) {
			para.appendChild(renderers[c.type](c));
		});
		return para;
	};
}

//TODO: need to add alignment stuff here
function renderRow(tag) {
	return function(tr) {
		var row = document.createElement('tr');
		tr.values.forEach(function(c) {
			var cell = document.createElement(tag);
			cell.appendChild(document.createTextNode(c));
			row.appendChild(cell);
		});
		return row;
	};
}

var renderers = {
	p: renderSpan('p'),
	header: function(h) {
		var header = document.createElement('h' + h.level);
		var tn = document.createTextNode(h.text);
		header.appendChild(tn);
		return header;
	},
	figure: function(f) {
		var figure = document.createElement('figure');
		var caption = document.createElement('figcaption');
		var ctext = document.createTextNode(f.caption);
		var img = document.createElement('img');
		img.src = f.src;
		img.alt = f.alt;
		figure.appendChild(img);
		caption.appendChild(ctext);
		figure.appendChild(caption);
		return figure;
	},
	code: function(c) {
		var code = document.createElement('code');
		var tn = document.createTextNode(c.text);
		code.appendChild(tn);
		if (c.lang) {
			code.className = 'lang-' + c.lang;
		}
		return code;
	},
	ulli:renderSpan('li'),
	olli:renderSpan('li'),
	quote:renderSpan('blockquote'),
	meta:function(c) {
		var code = document.createElement('span');
		var tn = document.createTextNode(c.text);
		code.appendChild(tn);
		return code;
	},
	'break':function(b) { return document.createElement('hr'); },
	tr:renderRow('td'),
	thr:renderRow('th'),
	strong:1,
	link:1,
	em:1,
	text:function(t) { return document.createTextNode(t.text); },
};

function render(model) {
	var df = document.createDocumentFragment();
	var i = 0;
	var gs;
	var l = model.length;
	while (i < l) {
		var para = model[i];
		if (gs = gatherers[para.type]) {
			var items = []; 
			var type = para.type;
			var lang = para.lang;
			do {
				items.push(para);
				i++;
			} while (i < l 
				&& !para.result
				&& lang === para.lang 
				&& (para=model[i]).type == type);
			df.appendChild(gs(items));
		} else {
			df.appendChild(renderers[para.type](para)); //don't gather
			i++;
		}
	}
	return df;
}


//Friar is almost react

var isDOMAttribute = {
	id: true,
	className: true,
	value: true,
};

function isListener(key) {
	return /^on[A-Z][a-zA-Z]+$/.test(key);
}

function keyToEvent(key) {
	return key.slice(2).toLowerCase();
}

function shouldUpdateComponent(prev, next) {
	if (prev && next && prev.type === next.type) return true;
	return false;
}

function Base() {}

Base.prototype.construct = function(props, children) {
	if (this.type === DOM.text.type) {
		this.props = { text: props };
		this.node = null;
		return;
	};

	this.props = props || {};
	this.node = null;

	if (arguments.length === 2) {
		if (typeof children == 'string' || typeof children === 'number') {
			this.props.children = [DOM.text(
				typeof children === 'number' ? '' + children : children)];
		} else {
			this.props.children = children; //passed an array of nodes (assumes we already mapped to text).
		}
	} else {
		var childArr = [];
		var prevChild, child;
		for (var i = 1; i < arguments.length; i++) {
			child = arguments[i];
			if (typeof child == 'string' || typeof child === 'number') {
				child = DOM.text(typeof child === 'number' ? '' + child : child);
			}
			if (prevChild
			 && child.type === DOM.text.type
			 && prevChild.type === DOM.text.type) {
				prevChild.props.text += child.props.text; //join text nodes together
			} else {
				childArr.push(child);
				prevChild = child;
			}
		}
		this.props.children = childArr;
	}
};

Base.prototype.unmount = function() {
	//remove listeners
	if (this._listeners && this.node) {
		for (var lk in this._listeners) {
			if (this._listeners.hasOwnProperty(lk)) {
				this.node.removeEventListener(lk, this._listeners[lk]);
			}
		}
	}
	//unmount children
	delete this.node;
};

Base.prototype.performUpdateIfNecessary = function() {
	if (this._pendingProps === null) {
		return;
	}
	var prevProps = this.props;
	this.props = this._pendingProps;
	this._pendingProps = null;
	this.updateComponent(prevProps);
};

Base.prototype.receiveComponent = function(nextComponent) {
	 this._pendingProps = nextComponent.props;
	 this.performUpdateIfNecessary();
	 //copy over our properties (TODO: probably better to use the ref stuff used by React)
	 nextComponent.node = this.node;
	 if (this._rendered) nextComponent._rendered = this._rendered;
};

function WrapBase(element) {
	this.node = element; this.props = { node: element };
}

WrapBase.prototype = new Base();

WrapBase.prototype.mount = function() {
	return this.node;
};

WrapBase.prototype.updateComponent = function(prevProps) {
	if (this.props.node === prevProps.node) return;
	prevProps.node.parentNode.replaceChild(this.props.node, prevProps.node);
	this.node = this.props.node;
};

function Wrap(element) {
	return new WrapBase(element);
}

WrapBase.prototype.type = WrapBase;
Wrap.type = WrapBase;


function DOMClass(tag) {
	this.tag = tag;
}

DOMClass.prototype = new Base();

DOMClass.prototype.mount = function() {
	if (this.node != null) {
		return this.node;
	}
	if (this.type === DOM.text.type) {
		this.node = document.createTextNode(this.props.text);
	} else {
		this.node = document.createElement(this.tag);
		for (var prop in this.props) {
			if (isDOMAttribute[prop]) {
				this.node[prop] = this.props[prop];
			} else if (prop === STYLE) {
				setValueForStyles(this.node, this.props[prop]);
			} else if (isListener(prop)) {
				this.addListener(prop, this.props[prop]);
			}
		}
		var node = this.node;
		this.props.children.forEach(function(child, index) { 
			child._mountIndex = index;
			node.appendChild(child.mount());
		});
	}
	return this.node;
};

DOMClass.prototype.addListener = function(key, func) {
	this._listeners = this._listeners || {};
	var name = keyToEvent(key);
	if (this._listeners.hasOwnProperty[name]) {
		this.node.removeEventListener(name, this._listeners[name]);
	}
	this._listeners[name] = function(e) { return func(e); };
	this.node.addEventListener(name, this._listeners[name]);
};

DOMClass.prototype.removeListener = function(key) {
	this._listeners = this._listeners || {};
	var name = keyToEvent(key);
	if (this._listeners.hasOwnProperty[name]) {
		this.node.removeEventListener(name, this._listeners[name]);
	}
};

//Different to React.js -- no nested children (arrays of arrays)
// will not be assuming that an objects keys are itterated over in order (not to js spec)
DOMClass.prototype.updateChildren = function(nextChildren, prevChildren) {
	var me = this;
	if (!nextChildren && !prevChildren) {
		return;
	}
	prevChildren = prevChildren || [];
	nextChildren = nextChildren || [];
	var prevChildrenByName = {};
	var pi = 0, ni = 0;
	prevChildren.forEach(function(c,i) { 
		prevChildrenByName[c.props.key ? '$' + c.props.key : '.' + (pi++)] = c;
	});
	var nextChildrenByName = {};
	var lastIndex = 0
	nextChildren.forEach(function(child, nextIndex) {
		var name = child.props.key ? '$' + child.props.key : '.' + (ni++);
		nextChildrenByName[name] = child;
		var prevChild = prevChildrenByName[name];
		if (shouldUpdateComponent(prevChild, child)) {
			//update
			me.moveChild(prevChild, nextIndex, lastIndex);
			lastIndex = Math.max(prevChild._mountIndex, lastIndex);
			prevChild.receiveComponent(child);
			prevChild._mountIndex = nextIndex;
			child._mountIndex = nextIndex;
			//nextChildren[nextIndex] = prevChild;
		} else {
			if (prevChild) {
				//replace
				lastIndex = Math.max(prevChild._mountIndex, lastIndex);
				me.replaceChild(child, prevChild);
				child._mountIndex = nextIndex;
			} else {
				//insert
				me.mountChildAtIndex(child, nextIndex);
			}
		}
	});
	//delete
	for (var name in prevChildrenByName) {
		if (prevChildrenByName.hasOwnProperty(name) &&
			!nextChildrenByName[name]) {
			me.unmountChild(prevChildrenByName[name]);
		}
	}
};

DOMClass.prototype.moveChild = function(child, toIndex, lastIndex) {
	if (child._mountIndex < lastIndex) {
		this.mountChildAtIndex(child, toIndex);
	}
};

DOMClass.prototype.mountChildAtIndex = function(child, index) {
	child._mountIndex = index;
	var childNode = child.mount();
	var parentNode = this.node;
	var childNodes = parentNode.childNodes;
	if (childNodes[index] === childNode) {
		return;
	}
	if (childNode.parentNode === parentNode) {
		parentNode.removeChild(childNode);
	}
	if (index >= childNodes.length) {
		parentNode.appendChild(childNode);
	} else {
		parentNode.insertBefore(childNode, childNodes[index]);
	}
};

DOMClass.prototype.unmountChild = function(child) {
	this.node.removeChild(child.node);
	child.unmount();
};

DOMClass.prototype.replaceChild = function(newChild, oldChild) {
	this.node.replaceChild(newChild.mount(), oldChild.node);
	oldChild.unmount();
};

DOMClass.prototype.updateComponent = function(prevProps) {
	if (this.type === DOM.text.type) {
		if (this.props.text != prevProps.text) {
			this.node.textContent = this.props.text;
		}
		return;
	}
	this._updateDOMProperties(prevProps);
	this.updateChildren(this.props.children, prevProps.children);
};

var STYLE = 'style';

//Inspired by React.js
DOMClass.prototype._updateDOMProperties = function(prevProps) {
	var nextProps = this.props;
	var styleUpdates;
	for (var key in prevProps) {
		if (nextProps.hasOwnProperty(key) ||
			!prevProps.hasOwnProperty(key)) {
				continue;
		}
		if (key === STYLE) {
			var prevStyle = prevProps[STYLE];
			for (var styleName in prevStyle) {
				if (prevStyle.hasOwnProperty(styleName)) {
					styleUpdate = styleUpdates || {};
					styleUpdate[styleName] = '';
				}
			}
		} else if (isDOMAttribute[key]) {
			this.node.removeAttribute(key);
		} else if (isListener(key)) {
			this.removeListener(key);
		}
	}
	for (var key in nextProps) {
    var nextProp = nextProps[key];
    var prevProp = prevProps[key];
		if (!nextProps.hasOwnProperty(key) || nextProp === prevProp) {
			continue;
		}
		if (key === STYLE) {
			if (prevProp) {
				for (var styleName in prevProp) {
					if (prevProp.hasOwnProperty(styleName) 
						&& !nextProp.hasOwnProperty(styleName)) {
						styleUpdates = styleUpdates || {};
						styleUpdates[styleName] = '';
					}
				}
				for (var styleName in nextProp) {
					if (nextProp.hasOwnProperty(styleName)
						&& prevProp[styleName] !== nextProp[styleName]) {
						styleUpdates = styleUpdates || {};
						styleUpdates[styleName] = nextProp[styleName];
					}
				}
			} else {
				styleUpdates = nextProp
			}
		} else if (isDOMAttribute[key]) {
			if (nextProp == null) {
				this.node.removeAttribute(key);
			} else {
				this.node.setAttribute(key, '' + nextProp);
			}
		} else if (isListener(key)) {
			this.addListener(key, nextProp); //addListener will remove old prop
		}
		if (styleUpdates) {
			setValueForStyles(this.node, styleUpdates);
		}
	}
};

function setValueForStyles(node, styles) {
  for (var styleName in styles) {
    if (!styles.hasOwnProperty(styleName)) {
      continue;
    }
    node.style[styleName] = styles[styleName];
	}
}

//Inspired by React.js
function createDOMClass(tag) {
	var Constructor = function() {};
	Constructor.prototype = new DOMClass(tag);
	Constructor.displayName = tag;

	var ConvConstructor = function(props, children) {
		var instance = new Constructor();
		instance.construct.apply(instance, arguments);
		return instance;
	};

	ConvConstructor.type = Constructor;
	Constructor.prototype.type = Constructor;

	return ConvConstructor;
}

var DOM = {};
[
	'a',
	'blockquote',
	'br',
	'code',
	'div',
	'em',
	'figure',
	'figcaption',
	'h1',
	'h2',
	'h3',
	'h4',
	'h5',
	'h6',
	'img',
	'li',
	'ol',
	'p',
	'pre',
	'section',
	'span',
	'strong',
	'sub',
	'sup',
	'table',
	'tbody',
	'td',
	'tfoot',
	'th',
	'thead',
	'tr',
	'ul',
	'text',
	'textarea'
].forEach(function(k,i) { DOM[k] = createDOMClass(k); });


var ComponentInterface = {
	render: true,
	didUpdate: true,
	willUpdate: true,
	didMount: true,
	willUnmount: true,
	getInitialState: true,
};

function ComponentBase() {}

ComponentBase.prototype = new Base();

ComponentBase.prototype.mount = function() {
	if (this.node) return this.node;

	//process props to include defaults
	this.state = this.getInitialState? this.getInitialState() : {};

	this._pendingState = null;
	this._pendingProps = null;
	this._pendingUpdate = false;
	//pendingForceUpdate = false

	//auto map (bind function to this)
	if (this.type._autoMap) {
		var autoMap = this.type._autoMap
		for (var name in autoMap) {
			if (autoMap.hasOwnProperty(name)) {
				this[name] = autoMap[name].bind(this);
			}
		}
	}

	this._rendered = this.render();
	this.node = this._rendered.mount();
	if (this.didMount) this.didMount(); 
	return this.node;
};

ComponentBase.prototype.performUpdateIfNecessary = function() {
	if (this._pendingProps === null && this._pendingState === null	&& !this._pendingUpdate) return;
	
	var nextState = this._pendingState || this.state;
	var nextProps = this._pendingProps || this.props;
	var prevProps = this.props;
  var prevState = this.state;
	
	this._pendingState = null;
	this._pendingProps = null;
	this._pendingUpdate = false;

  if (this.willUpdate) {
    this.willUpdate(nextProps, nextState);
  }

  this.props = nextProps;
  this.state = nextState;

  this.updateComponent(prevProps, prevState);

  if (this.didUpdate) {
		this.didUpdate(prevProps, prevState);
  }
};

ComponentBase.prototype.updateComponent = function(prevProps) {
	var prevRendered = this._rendered;
	var nextRendered = this.render();
	if (shouldUpdateComponent(prevRendered, nextRendered)) {
		prevRendered.receiveComponent(nextRendered);
	} else {
		//TODO: should we be calling didMount?
		this._rendered = nextRendered;
		var node = this._rendered.mount();
		this.node.parentNode.replaceChild(node, prevRendered.node);
		prevRendered.unmount();
	}
};

ComponentBase.prototype.forceUpdate = function() {
	this._pendingUpdate = true;
	this.performUpdateIfNecessary();
};

ComponentBase.prototype.setState = function(obj) {
	this._pendingState = merge(this._pendingState || this.state, obj);
	this.performUpdateIfNecessary();
};

function merge(base, upd) {
	var result = {}
	for (var k in base) result[k] = base[k];
	for (var k in upd) result[k] = upd[k];
	return result;
}

/*
TextNode.prototype.receiveComponent = function(nextComponent) {
    var nextProps = nextComponent.props;
    if (nextProps.text !== this.props.text) {
      this.props.text = nextProps.text;
		  this.node.textContent = this.props.text;
    }
};
*/

function createClass(spec) {
	var Constructor = function() {};
	Constructor.prototype = new ComponentBase();

	var ConvConstructor = function(props, children) {
		var instance = new Constructor();
		instance.construct.apply(instance, arguments);
		return instance;
	};

	//mixin
	for (var name in spec) {
		if (!spec.hasOwnProperty(name)) continue;
		Constructor.prototype[name] = spec[name];
		var property = spec[name];
		var isFunction = typeof property === 'function';
		var isInterface = name in ComponentInterface;
		if (isFunction && !isInterface) {
			Constructor._autoMap = Constructor._autoMap || {};
			Constructor._autoMap[name] = property;
		}
	};

	ConvConstructor.type = Constructor;
	Constructor.prototype.type = Constructor;

	return ConvConstructor;
}

function renderComponent(component, element) {
	element.appendChild(component.mount());
}


var Preview = createClass({
	render: function() {
		var result = document.createElement('div');
		result.appendChild(render(this.props.model));
		return DOM.div({id: 'preview', className: 'editor'}, [Wrap(result)]);
	}
});


var IgnoreKeys = {
	Shift: false,
	Win: false,
	Control: false,
	CapsLock: false,
	Alt: false,
	Meta: false,
	Left: true,
	Right: true,
	Up: true,
	Down: true,
};

var Editor = createClass({
	getInitialState: function() {
		var text = this.props.text;
		return {
			text: text,
			model: parse(text),
		};
	},
	updateText: function() {
		var text = this.textarea.node.value;
		if (text == this.state.text) return;
		this.setState({text: text, model: parse(text)}); //TODO: model update rather than reparse
	},
	handleChange: function(e) {
		this.updateText();
	},
	handleKeyDown: function(e) {
		console.log(e.keyIdentifier + ' is down');
		this.updateText();
	},
	handleKeyUp: function(e) {
		console.log(e.keyIdentifier + ' is up');
		this.updateText();
	},
	handleFocus: function(e) {
		this.updateText();
	},
	handleBlur: function(e) {
		this.updateText();
	},
	handleInput: function(e) {
		this.updateText();
	},
	handleContentKeyDown: function(e) {
		//Ignore movement keys...
		var key = e.key || e.keyIdentifier;
		if (IgnoreKeys.hasOwnProperty(key)
			&& (!IgnoreKeys[key]
			||e.ctrlKey||e.shiftKey||e.altKey||e.metaKey)) {
			return;
		}
		console.log(key);
		this.blur = document.activeElement !== this.textarea.node;
		if (this.blur) this.textarea.node.focus();
		//Set selection in textarea so the key make the change
	},
	handleContentKeyUp: function(e) {
		if (this.blur) {
			this.textarea.node.blur();
			this.blur = false;
		}
	},
	didMount: function() {
		console.log('mounted');
		//TODO: this stuff should be on the actual textarea node itself
		document.body.addEventListener('keydown', this.handleContentKeyDown.bind(this));
		document.body.addEventListener('keyup', this.handleContentKeyUp.bind(this));
	},
	didUpdate: function() {
		console.log('updated');
	},
	willUnmount: function() {
		console.log('unmounting');
	},
	render: function() {
		//?? does this work when we are going with previous Child and updating
		this.textarea = DOM.textarea({
			id: 'model', 
			style: {width: '100%', height: '100px'}, 
			value: this.state.text,
			onKeyDown: this.handleKeyDown,
			onKeyUp: this.handleKeyUp,
			onFocus: this.handleFocus,
			onBlur: this.handleBlur,
			onChange: this.handleChange,
			onInput: this.handleInput,
		});
		return DOM.div({className: 'content'}, 
			this.textarea,
			Preview({model: this.state.model}));
	}
});


var text = "#Clay\n"
		 + "This is a paragraph\n"
		 + "|this|is|a|table\n"
		 + "|more|table|stuff|here\n"
		 + "This is another paragraph\n"
		 + " This is some code\n"
		 + " This is another code line\n"
		 + " This is a line that has a continued line after it\n"
		 + "  this is the continued line here\n"
		 + " function something() {\n"
		 + "   //this is some javascript that gets automatically detected.\n"
		 + " }\n"
		 + "This is a paragraph\n"
		 + "*This is a list item\n"
		 + "*this is another list item\n"
		 + ".This is a numbered list item\n"
		 + ".This is another numbered list item\n"
		 + "This is another paragraph\n"
		 + "##This is a sub header\n"
		 + "This is a paragraph with *bold* text and _italic_ text in it\n"
		 + "This is a paragraph with a link [this is link text][1].\n"
		 + ">This is a blockquote\n"
		 + "-\n"
		 + "The dash before a paragraph is a section break (that might be rendered as an hr - note.. change so it doesn't need to be on its own line but can live before a paragraph or other element)\n"
		 + "![alt text](css/fonts/glyphicons-halflings.png)figure text here\n"
		 + "%Meta Stuff\n"
		 + "Idea ... use non printing characters to stand in for bold and italics and links in the code so that you don't have extra characters to delete or insert in those cases. This might not help much. It might be easier to just store the list and manage it based on keypresses.\n"
		 + "There is an empty paragraph at the end after this one.\n"
		 + "\n"
		 + "[1](http://google.co.uk \"Google\")\n";

var x;
renderComponent(x = new Editor({text: text}), main);

</script>
</body>
</html>