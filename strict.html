<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<meta http-equiv="Content-Type" content="application/xhtml+xml">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title></title>
<link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,700|Inconsolata" />
<link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.5.0/pure-min.css"/>

<!--[if lte IE 8]>
    <link rel="stylesheet" href="css/layouts/side-menu-old-ie.css">
<![endif]-->
<!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="css/layouts/side-menu.css">
<!--<![endif]-->
<link rel="stylesheet" href="css/clay.css"/>
<style type="text/css">
/* stuff here */

figcaption {
	position: absolute;
	top: 0;
	left: -170px;
	width: 150px;
	font-style: italic;
	text-align: right;
	color: rgba(0,0,0,0.5);
	font-family: serif;
}
figcaption:before {
	width: 35%;
	margin-left: 65%;
	border-top: 1px solid #edece4;
	display: block;
	content: '';
	margin-bottom: 5px;
}
figure {
	position: relative;
	clear: both;
}
hr {
	border-top: 1px solid #edece4;
	border-bottom: 0;
	border-left: 0;
	border-right: 0;
}
section:after {
	width: 16%;
	margin-left: 38%;
	border-top: 1px solid #edece4;
	display: block;
	content: '';
	margin-top: 50px;
	margin-bottom: 50px;
}
pre[class*='lang-javascript'] {
	background-color: #2A2C39;
}
pre[class*='lang-javascript'] > code {
	color: #E9E9EB;
}
</style>
</head>
<body>
<div id="layout">
    <!-- Menu toggle -->

    <div id="main">
	</div>
</div>
<script type="text/javascript" src="js/friar.js"></script>
<script type="text/javascript" src="js/cube.js"></script>
<script type="text/javascript">

var DOM = Friar.DOM, 
    createClass = Friar.createClass,
    Model = Cube.Model,
    parse = Cube.parse;

var KEY_PREFIX = 'clay:'

function keyToId(key) {
	return KEY_PREFIX + key.toString(36);
}

function idToKey(id) {
	return parseInt(id.slice(KEY_PREFIX.length), 36);
}

// render model to array of Friar components
function renderToFriar(model) {
	var rendered = [];
	var tokens = model.cells;
	var index = 0;
	var token;
	
	function getToken() {
		return token = tokens[index++];
	}

	function ungetToken() {
		return token = tokens[(--index)-1];
	}

	function renderSpans(item) {
		if (item.spans.length === 0) {
			return [DOM.br()]; //id: keyToId(token.key)
		}
		return item.spans.map(function(c) {
			return DOM.text(c.text); //TODO: assmuing everything is text
		});
	}

	function renderRow(type, alignments) {
		return DOM.tr({id: keyToId(token.key)},token.values.map(function(c,i) { //
			return DOM[type]({style: (alignments[i] || {})}, c); //TODO (c should be spans)
		}));
	}

	//TODO: probably want to replace this with a class
	// so we can check the table has not changed and not
	// render again. (Would need a row class - only save generating the cells)
	function renderTable() {
		var hrows = [], rows=[], i = 0, alignments;
		while (token && token.type === 'tr') {
			if (i === 0) {
				alignments = token.values.map(function(c) {
					return /^ /.test(c) ? 
						{'text-align': (/ $/.test(c) ? 'center' : 'right')} : {};
				});
				hrows.push(renderRow('th', alignments));
			} else {
				rows.push(renderRow('td', alignments));
			}
			i++;
			getToken();
		}
		ungetToken();
		return [DOM.table({className: 'pure-table pure-table-bordered'}, 
			DOM.thead({},hrows), 
			DOM.tbody({},rows))];
	}

	function renderCode(lang) {
		var items = [];
		var langClass;
		while (token && token.type === 'code' && !token.result && token.lang === lang) {
			var props = {id: keyToId(token.key)};//TODO: add key
			if (token.lang) langClass = props.className = 'lang-' + token.lang
			items.push(DOM.code(props,token.text)); 
			getToken();
		}
		ungetToken();
		return [DOM.pre({className: langClass}, items)];
	}

	function renderList(listType, itemType) {
		var items = [];
		while (token && token.type === itemType) {
			items.push(DOM.li({id: keyToId(token.key)},renderSpans(token))); //TODO: add key
			getToken();
		}
		ungetToken();
		return [DOM[listType]({}, items)];
	}

	function renderFigure() {
		var f = token;
		return [DOM.figure({id: keyToId(token.key)},
			DOM.img({alt: f.alt, src: f.src}),
			DOM.figcaption({}, f.caption)
		)];
	}

	function renderPara() {
		switch (token.type) {
			case 'code':   return renderCode(token.lang);
			case 'p':      return [DOM.p({id: keyToId(token.key)}, renderSpans(token))];
			case 'header': return [DOM['h'+token.level]({id: keyToId(token.key)}, token.text)];
			case 'figure': return renderFigure();
			case 'ulli':   return renderList('ul', 'ulli');
			case 'olli':   return renderList('ol', 'olli');
			case 'quote':  return [DOM.blockquote({id: keyToId(token.key)}, renderSpans(token))];
			case 'tr':     return renderTable();
			default: 
				return [
					DOM.p({className: 'error', id: keyToId(token.key)}, 
						"Error: Don't know what to do with a " + token.type)
				];
		}
	}

	function renderSection() {
		var children = [];
		getToken();
		while (token && token.type !== 'break') {
			Array.prototype.push.apply(children, renderPara());
			getToken();
		};
		return DOM.section({}, children);
	}

	while (index < tokens.length) {
		rendered.push(renderSection());
	}
	return rendered;
}

var Preview = createClass({
	render: function() {
		return DOM.div({id: 'preview', className: 'editor'}, 
			renderToFriar(this.props.model));
	}
});


var IgnoreKeys = {
	Shift: false,
	Win: false,
	Control: false,
	CapsLock: false,
	Alt: false,
	Meta: false,
	Left: true,
	Right: true,
	Up: true,
	Down: true,
};

var Editor = createClass({
	getInitialState: function() {
		var text = this.props.text;
		return {
			text: text,
			model: new Model(parse(text)),
		};
	},
	updateText: function() {
		var text = this.textarea.node.value;
		if (text == this.state.text) return;
		this.setState({text: text, model: this.state.model.merge(parse(text))});
	},
	handleChange: function(e) {
		this.updateText();
	},
	handleKeyDown: function(e) {
		this.updateText();
	},
	handleKeyUp: function(e) {
		this.updateText();
	},
	handleFocus: function(e) {
		this.updateText();
	},
	handleBlur: function(e) {
		this.updateText();
	},
	handleInput: function(e) {
		this.updateText();
	},
	handleContentKeyDown: function(e) {
		//Ignore movement keys...
		var key = e.key || e.keyIdentifier;
		if (IgnoreKeys.hasOwnProperty(key)
			&& (!IgnoreKeys[key]
			||e.ctrlKey||e.shiftKey||e.altKey||e.metaKey)) {
			return;
		}
		//console.log(key);
		this.blur = document.activeElement !== this.textarea.node;
		if (this.blur) this.textarea.node.focus();
		//Set selection in textarea so the key make the change
	},
	handleContentKeyUp: function(e) {
		if (this.blur) {
			this.textarea.node.blur();
			this.blur = false;
		}
	},
	didMount: function() {
		console.log('mounted');
		//TODO: this stuff should be on the actual textarea node itself
		document.body.addEventListener('keydown', this.handleContentKeyDown);
		document.body.addEventListener('keyup', this.handleContentKeyUp);
	},
	didUpdate: function() {
		console.log('updated');
	},
	willUnmount: function() {
		console.log('unmounting');
	},
	render: function() {
		//?? does this work when we are going with previous Child and updating
		this.textarea = DOM.textarea({
			id: 'model', 
			style: {width: '100', height: '50px', opacity: '0', 
			        position: 'absolute', left: '-3000px'}, 
			value: this.state.text,
			onKeyDown: this.handleKeyDown,
			onKeyUp: this.handleKeyUp,
			onFocus: this.handleFocus,
			onBlur: this.handleBlur,
			onChange: this.handleChange,
			onInput: this.handleInput,
		});
		return DOM.div({className: 'content'}, 
			this.textarea,
			Preview({model: this.state.model}));
	}
});

var text = "#Cube\n"
		 + "This is a paragraph\n"
		 + "|this|is|a|table\n"
		 + "|more|table|stuff|here\n"
		 + "This is another paragraph\n"
		 + " This is some code\n"
		 + " This is another code line\n"
		 + " This is a line that has a continued line after it\n"
		 + "  this is the continued line here\n"
		 + " function something() {\n"
		 + "   //this is some javascript that gets automatically detected.\n"
		 + " }\n"
		 + " This is some code after the javascript\n"
		 + "This is a paragraph\n"
		 + "*This is a list item\n"
		 + "*this is another list item\n"
		 + ".This is a numbered list item\n"
		 + ".This is another numbered list item\n"
		 + "This is another paragraph\n"
		 + "##This is a sub header\n"
		 + "This is a paragraph with *bold* text and _italic_ text in it\n"
		 + "This is a paragraph with a link [this is link text][1].\n"
		 + ">This is a blockquote\n"
		 + "-"
		 + "The dash before a paragraph is a section break (that might be rendered as an hr - note.. change so it doesn't need to be on its own line but can live before a paragraph or other element)\n"
		 + "![alt text](css/fonts/glyphicons-halflings.png)figure text here\n"
		 + "Idea ... use non printing characters to stand in for bold and italics and links in the code so that you don't have extra characters to delete or insert in those cases. This might not help much. It might be easier to just store the list and manage it based on keypresses.\n"
		 + "There is an empty paragraph at the end after this one.\n"
		 + "\n"
		 + "[1](http://google.co.uk \"Google\")\n";

var x;
Friar.renderComponent(x = new Editor({text: text}), document.getElementById('main'));

</script>
</body>
</html>