<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<meta http-equiv="Content-Type" content="application/xhtml+xml">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title></title>
<link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,700|Inconsolata" />
<link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.5.0/pure-min.css"/>

<!--[if lte IE 8]>
    <link rel="stylesheet" href="css/layouts/side-menu-old-ie.css">
<![endif]-->
<!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="css/layouts/side-menu.css">
<!--<![endif]-->
<link rel="stylesheet" href="css/clay.css"/>
<style type="text/css">
/* stuff here */
</style>
</head>
<body>
<div id="layout">
    <!-- Menu toggle -->

    <div id="main">
		<div class="content">
		<textarea id='textarea' style='width: 100%; height: 100px;'>
#Header
This is a paragraph
|this|is|a|table
|more|table|stuff|here
This is another paragraph
 This is some code
 This is another code line
 This is a line that has a continued line after it
  this is the continued line here
 function something() {
   //this is some javascript that gets automatically detected.
 }
This is a paragraph
*This is a list item
*this is another list item
.This is a numbered list item
.This is another numbered list item
This is another paragraph
##This is a sub header
This is a paragraph with *bold* text and _italic_ text in it
This is a paragraph with a link [this is link text][1].
>THis is a blockquote
-
The dash before a paragraph is a section break (that might be rendered as an hr - note.. change so it doesn't need to be on its own line but can live before a paragraph or other element)
![alt text](link)figure text here
%Meta Stuff
Idea ... use non printing characters to stand in for bold and italics and links in the code so that you don't have extra characters to delete or insert in those cases. This might not help much. It might be easier to just store the list and manage it based on keypresses.
There is an empty paragraph at the end after this one.

[1](http://google.co.uk "Google")</textarea>
		<div id='preview'></div>
</div>
</div>
</div>
<script type="text/javascript">
var textarea = document.getElementById('textarea');
var preview = document.getElementById('preview');

var parsers = {
	'#': function(l) {
		var level = /^#+/.exec(l)[0].length;
		return {type: 'header', level: level, raw: l, text: l.slice(level)};
	},
	p: function(l) {
		//TODO: spans
		return {type: 'p', raw: l, spans: (l.length > 0 ? [{type: 'text', text: l}] : [])};
	},
	'!': function(l) {
		if (sub = /^!\[([^\]]*)\]\(([^\)]*)\)(.*)/.exec(l)) {
			return {type: 'figure', alt: sub[1], src: sub[2], caption: sub[3], raw:l};
		}
		return parsers.p(l);
	},
	' ': function(l) { 
		return {type: 'code', raw: l, text: l.slice(1) + '\n'};
	},
	'*': function(l) { 
		return {type: 'ulli', raw: l, spans: [{type: 'text', text: l.slice(1)}]};
	},
	'.': function(l) { 
		return {type: 'olli', raw: l, spans: [{type: 'text', text: l.slice(1)}]};
	},
	'>': function(l) { 
		return {type: 'quote', raw: l, spans: [{type: 'text', text: l.slice(1)}]}; 
	},
	'%': function(l) { 
		return {type: 'meta', raw: l, text: l.slice(1)}; 
	},
	'-': function(l) {
		if (l.length === 1) return {type: 'break', raw: l};
		return parsers.p(l);
	},
	'|': function(l) {
		return {type: 'tr', raw: l, values: l.slice(1).split('|')};
	},
}

function parse(text) {
	return text.split('\n').map(function(l,i) {
		var cap;
		if (cap = /^[\#\!\% \*\.\>\-\|]/.exec(l)) {
			if (parsers.hasOwnProperty(cap[0])) return parsers[cap[0]](l);
		}
		return parsers.p(l);
	});
}

var model = parse(textarea.value);


function gatherAll(tag) {
	return function(items) {
		var elm = document.createElement(tag);
		items.forEach(function(el,i) {
			elm.appendChild(renderers[el.type](el));
		});
		return elm;
	};
}

var gatherers = {
	ulli: gatherAll('ul'),
	olli: gatherAll('ol'),
	code: gatherAll('pre'), //TODO: replace to return a result element (document fragment)
	tr: function(items) {
		var thead = document.createElement('thead');
		var tbody = document.createElement('tbody');
		var table = document.createElement('table');
		table.className = 'pure-table pure-table-bordered';
		table.appendChild(thead);
		table.appendChild(tbody);
		items.forEach(function(tr, i) {
			if (i == 0) thead.appendChild(renderers.thr(tr));
			else tbody.appendChild(renderers.tr(tr));
		});
		return table;
	},
};

function renderSpan(tag) {
	return function(item) {
		var para = document.createElement(tag);
		if (item.spans.length === 0) para.appendChild(document.createElement('br'));
		item.spans.forEach(function(c) {
			para.appendChild(renderers[c.type](c));
		});
		return para;
	};
}

//TODO: need to add alignment stuff here
function renderRow(tag) {
	return function(tr) {
		var row = document.createElement('tr');
		tr.values.forEach(function(c) {
			var cell = document.createElement(tag);
			cell.appendChild(document.createTextNode(c));
			row.appendChild(cell);
		});
		return row;
	};
}

var renderers = {
	p: renderSpan('p'),
	header: function(h) {
		var header = document.createElement('h' + h.level);
		var tn = document.createTextNode(h.text);
		header.appendChild(tn);
		return header;
	},
	figure: function(f) {
		var figure = document.createElement('figure');
		var caption = document.createElement('figcaption');
		var ctext = document.createTextNode(f.caption);
		var img = document.createElement('img');
		img.src = f.src;
		img.alt = f.alt;
		figure.appendChild(img);
		caption.appendChild(ctext);
		figure.appendChild(caption);
		return figure;
	},
	code: function(c) {
		var code = document.createElement('code');
		var tn = document.createTextNode(c.text);
		code.appendChild(tn);
		if (c.lang) {
			code.className = 'lang-' + c.lang;
		}
		return code;
	},
	ulli:renderSpan('li'),
	olli:renderSpan('li'),
	quote:renderSpan('blockquote'),
	meta:function(c) {
		var code = document.createElement('span');
		var tn = document.createTextNode(c.text);
		code.appendChild(tn);
		return code;
	},
	'break':function(b) { return document.createElement('hr'); },
	tr:renderRow('td'),
	thr:renderRow('th'),
	strong:1,
	link:1,
	em:1,
	text:function(t) { return document.createTextNode(t.text); },
};

function render(model) {
	var df = document.createDocumentFragment();
	var i = 0;
	var gs;
	var l = model.length;
	while (i < l) {
		var para = model[i];
		if (gs = gatherers[para.type]) {
			var items = []; 
			var type = para.type;
			var lang = para.lang;
			do {
				items.push(para);
				i++;
			} while (i < l 
				&& !para.result
				&& lang === para.lang 
				&& (para=model[i]).type == type);
			df.appendChild(gs(items));
		} else {
			df.appendChild(renderers[para.type](para)); //don't gather
			i++;
		}
	}
	return df;
}


//React-A-Like

var isDOMAttribute = {
	id: true,
	className: true,
	value: true,
};

function shouldUpdateComponent(prev, next) {
	if (prev.type === next.type) return true;
	return false;
}


function Base() {}

Base.prototype.construct = function(props, children) {
	if (this.type === DOM.text.type) {
		this.props = { children: props };
		this.node = null;
		return;
	};

	this.props = props || {};
	this.node = null;

	if (arguments.length === 2) {
		if (typeof children == 'string') {
			this.props.children = [DOM.text(children)];
		} else {
			this.props.children = children; //passed an array of nodes.
		}
	} else {
		var childArr = [];
		var prevChild, child;
		for (var i = 1; i < arguments.length; i++) {
			child = arguments[i];
			if (typeof child == 'string') {
				child = DOM.text(child);
			}
			if (prevChild
			 && child.type === DOM.text.type
			 && prevChild.type === DOM.text.type) {
				prevChild.props.children += child.props.children; //join text nodes together
			} else {
				childArr.push(child);
				prevChild = child;
			}
		}
		this.props.children = childArr;
	}
};

Base.prototype.unmount = function() {
	delete this.node;
};

Base.prototype.performUpdateIfNecessary = function() {
	if (this._pendingProps === null) {
		return;
	}
	var prevProps = this.props;
	this.props = this._pendingProps;
	this._pendingProps = null;
	this.updateComponent(prevProps);
};

Base.prototype.receiveComponent = function(nextComponent) {
	 this._pendingProps = nextComponent.props;
	 this.performUpdateIfNecessary();
};


function DOMClass(tag) {
	this.tag = tag;
}

DOMClass.prototype = new Base();

DOMClass.prototype.mount = function() {
	if (this.node != null) {
		return this.node;
	}
	if (this.type === DOM.text.type) {
		this.node = document.createTextNode(this.props.children);
	} else {
		var node = document.createElement(this.tag);
		for (var prop in this.props) {
			if (isDOMAttribute[prop]) {
				node[prop] = this.props[prop];
			} else if (prop === STYLE) {
				setValueForStyles(node, this.props[prop]);
			}
		}
		this.props.children.forEach(function(child, index) { 
			node.appendChild(child.mount());
		});
		this.node = node;
	}
	return this.node;
};

//Different to React.js -- no nested children (arrays of arrays)
// will not be assuming that an objects keys are itterated over in order (not to js spec)
// assume that almost all DOM changes (including those that need to be fast) are inserts,
// deletes, and updates. We still use keys to indicate if it is the same object.
DOMClass.prototype.updateChildren = function(nextChildren, prevChildren) {
	if (!nextChildren && !prevChildren) {
		return;
	}
	prevChildren = prevChildren || [];
	nextChildren = nextChildren || [];
	//use difference in length to tell if we are doing an insert,
	// update, or delete
	var lenDiff = prevChildren.length - nextChildren.length;
	
	nextChildren.forEach(function(child, index) {
		//should Update/replace
		// should delete
		// should insert
	});
	//use final lenDiff to remove children no longer present
	
	//TODO: do this next... it does the list and key comparison...
};

DOMClass.prototype.updateComponent = function(prevProps) {
	this._updateDOMProperties(prevProps);
	this.updateChildren(this.props.children, prevProps.children);
};

var STYLE = 'style';

//Inspired by React.js
DOMClass.prototype._updateDOMProperties = function(prevProps) {
	var nextProps = this.props;
	var styleUpdates;
	for (var key in prevProps) {
		if (nextProps.hasOwnProperty(key) ||
			!prevProps.hasOwnProperty(key)) {
				continue;
		}
		if (key === STYLE) {
			var prevStyle = prevProps[STYLE];
			for (var styleName in prevStyle) {
				if (prevStyle.hasOwnProperty(styleName)) {
					styleUpdate = styleUpdates || {};
					styleUpdate[styleName] = '';
				}
			}
		} else if (isDOMAttribute[key]) {
			this.node.removeAttribute(key);
		}
	}
	for (var key in nextProps) {
    var nextProp = nextProps[key];
    var prevProp = prevProps[key];
		if (!nextProps.hasOwnProperty(key) || nextProp === prevProp) {
			continue;
		}
		if (key === STYLE) {
			if (prevProp) {
				for (var styleName in prevProp) {
					if (prevProp.hasOwnProperty(styleName) && !nextProp.hasOwnProperty(styleName)) {
						styleUpdates = styleUpdates || {};
						styleUpdates[styleName] = '';
					}
				}
				for (var styleName in nextProp) {
					if (nextProp.hasOwnProperty(styleName) && prevProp[styleName] !== nextProp[styleName]) {
						styleUpdates = styleUpdates || {};
						styleUpdates[styleName] = nextProp[styleName];
					}
				}
			} else {
				styleUpdates = nextProp
			}
		} else if (isDOMAttribute[key]) {
			if (nextProp == null) {
				this.node.removeAttribute(key);
			} else {
				this.node.setAttribute(key, '' + nextProp);
			}
		}
		if (styleUpdates) {
			setValueForStyles(this.node, styleUpdates);
		}
	}
};

function setValueForStyles(node, styles) {
  for (var styleName in styles) {
    if (!styles.hasOwnProperty(styleName)) {
      continue;
    }
    node.style[styleName] = styles[styleName];
	}
}

//Inspired by React.js
function createDOMClass(tag) {
	var Constructor = function() {};
	Constructor.prototype = new DOMClass(tag);
	Constructor.displayName = tag;

	var ConvConstructor = function(props, children) {
		var instance = new Constructor();
		instance.construct.apply(instance, arguments);
		return instance;
	};

	ConvConstructor.type = Constructor;
	Constructor.prototype.type = Constructor;

	return ConvConstructor;
}

var DOM = {};
[
	'a',
	'blockquote',
	'br',
	'code',
	'div',
	'em',
	'figure',
	'figcaption',
	'h1',
	'h2',
	'h3',
	'h4',
	'h5',
	'h6',
	'img',
	'li',
	'ol',
	'p',
	'pre',
	'section',
	'span',
	'strong',
	'sub',
	'sup',
	'table',
	'tbody',
	'td',
	'tfoot',
	'th',
	'thead',
	'tr',
	'ul',
	'text',
	'textarea'
].forEach(function(k,i) { DOM[k] = createDOMClass(k); });


function ComponentBase() {}

ComponentBase.prototype = new Base();

ComponentBase.prototype.mount = function() {
	if (this.node) return this.node;

	//process props to include defaults
	this.state = this.getInitialState? this.getInitialState() : {};

	this._pendingState = null;
	this._pendingProps = null;
	this._pendingUpdate = false;
	//pendingForceUpdate = false

	this._rendered = this.render();
	this.node = this._rendered.mount();
	if (this.didMount) this.didMount(); 
	return this.node;
};

ComponentBase.prototype.performUpdateIfNecessary = function() {
	if (this._pendingProps === null && this._pendingState === null	&& !this._pendingUpdate) return;
	
	var nextState = this._pendingState || this.state;
	var nextProps = this._pendingProps || this.props;
	var prevProps = this.props;
  var prevState = this.state;
	
	this._pendingState = null;
	this._pendingProps = null;
	this._pendingUpdate = false;

  if (this.willUpdate) {
    this.willUpdate(nextProps, nextState);
  }

  this.props = nextProps;
  this.state = nextState;

  this.updateComponent(prevProps, prevState);

  if (this.didUpdate) {
		this.didUpdate(prevProps, prevState);
  }
};

ComponentBase.prototype.updateComponent = function(prevProps) {
	var prevRendered = this._rendered;
	var nextRendered = this.render();
	if (shouldUpdateComponent(prevRendered, nextRendered)) {
		prevRendered.receiveComponent(nextRendered);
	} else {
		//TODO: should we be calling didMount?
		this._rendered = nextRendered;
		var node = this._rendered.mount();
		this.node.parentNode.replaceChild(prevRendered.node, node);
		prevRendered.unmount();
	}
};

ComponentBase.prototype.forceUpdate = function() {
	this._pendingUpdate = true;
	this.performUpdateIfNecessary();
};


/*
TextNode.prototype.receiveComponent = function(nextComponent) {
    var nextProps = nextComponent.props;
    if (nextProps.text !== this.props.text) {
      this.props.text = nextProps.text;
		  this.node.textContent = this.props.text;
    }
};
*/


function createClass(spec) {
	var Constructor = function() {};
	Constructor.prototype = new ComponentBase();

	var ConvConstructor = function(props, children) {
		var instance = new Constructor();
		instance.construct.apply(instance, arguments);
		return instance;
	};

	//mixin
	for (var name in spec) {
		if (!spec.hasOwnProperty(name)) continue;
		Constructor.prototype[name] = spec[name];
	};

	ConvConstructor.type = Constructor;
	Constructor.prototype.type = Constructor;

	return ConvConstructor;
}


var Test = createClass({
	render: function() {
		return DOM.div({className: 'test'}, 
			DOM.span({}, "Some text in a span"), 
			DOM.br(), 
			"Some more text");
	}
});


var Preview = createClass({
	render: function() {
		return DOM.div({className: 'preview'}, 
			DOM.span({style: {'font-weight': 700}}, "Some text in a span"), 
			DOM.br(), 
			"Some more text");
	}
})

var Editor = createClass({
	getInitialState: function() {
		return {};
	},
	render: function() {
		this.textarea = DOM.textarea({id: 'model'});
		return DOM.div({className: 'content'}, 
			this.textarea,
			Preview());
	}
})



</script>
</body>
</html>