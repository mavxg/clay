<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<meta http-equiv="Content-Type" content="application/xhtml+xml">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title></title>
<link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,700|Inconsolata" />
<link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.5.0/pure-min.css"/>

<!--[if lte IE 8]>
    <link rel="stylesheet" href="css/layouts/side-menu-old-ie.css">
<![endif]-->
<!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="css/layouts/side-menu.css">
<!--<![endif]-->
<link rel="stylesheet" href="css/clay.css"/>
<style type="text/css">
.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.x.axis path {
  display: none;
}

.line {
  fill: none;
  stroke: steelblue;
  stroke-width: 1.5px;
}

figcaption {
	position: absolute;
	top: 0;
	left: -170px;
	width: 150px;
	font-style: italic;
	text-align: right;
	color: rgba(0,0,0,0.5);
	font-family: serif;
}
figcaption:before {
	width: 35%;
	margin-left: 65%;
	border-top: 1px solid #edece4;
	display: block;
	content: '';
	margin-bottom: 5px;
}
figure {
	position: relative;
	clear: both;
}
td.empty {
	height: 20px;
	border-bottom: 1px dotted #cbcbcb;
}
hr {
	border-top: 1px solid #edece4;
	border-bottom: 0;
	border-left: 0;
	border-right: 0;
}
section:after {
	width: 16%;
	margin-left: 38%;
	border-top: 1px solid #edece4;
	display: block;
	content: '';
	margin-top: 50px;
	margin-bottom: 50px;
}
pre[class*='lang-javascript'] {
	background-color: #2A2C39;
}
pre[class*='lang-javascript'] > code {
	color: #E9E9EB;
}
pre[class*='lang-sexpr'] {
	display: none;
	background-color: #283593;
}
pre[class*='lang-sexpr'] > code {
	color: #E9E9EB;
}
.show-debug pre[class*='lang-sexpr'] {
	display: block;
	background-color: #283593;
}

.error {
	color: red;
}
textarea.hiddenTextArea {
	width: 100%;
	max-width: 800px;
	font-family: 'Open Sans', 'Segoe UI', verdana, sans-serif;
	height: 50px;
	opacity: 0;
	position: absolute;
	left: -3000px;
}
#cursor {
	pointer-events:none; /* so clicks get passed through - Tested: Chrome, firefox, IE11 */
}
</style>
</head>
<body>
<div id="cursor"></div>
<div id="view">
</div>
<script type="text/javascript" src="js/friar.js"></script>
<script type="text/javascript" src="js/cube.js"></script>
<script type="text/javascript" src="js/macros.js"></script>
<script type="text/javascript" src="js/functions.js"></script>
<script src="http://d3js.org/d3.v3.js"></script>
<script type="text/javascript" src="js/functions/graph.js"></script>
<script type="text/javascript">

var DOM = Friar.DOM, 
    createClass = Friar.createClass,
    Model = Cube.Model,
    parseRaw = Cube.parseRaw;

var KEY_PREFIX = 'clay:';
var reKey = /clay:/;

function keyToId(key) {
	return KEY_PREFIX + key.toString(36);
}

function idToKey(id) {
	return parseInt(id.slice(KEY_PREFIX.length), 36);
}

var Table = createClass({
	render: function() {
		var token = this.props;
		var rows = token.rows;
		var alignments = token.alignments;

		//TODO: give the rows keys within the table
		function renderRow(row, type, alignments) {
			return DOM.tr({id: keyToId(token.key) + '.' + row.key.toString(36)},
				row.cells.length > 0 ? row.cells.map(function(c,i) {
					return DOM[type]({style: (alignments[i] || {})}, c); //TODO (c should be spans)
				}) : [DOM.td({className: 'empty', colSpan: alignments.length},' ')]);
		}

		return DOM.table({id: keyToId(token.key),  
						  className: 'pure-table pure-table-bordered'}, 
			DOM.thead({},[renderRow(rows[0], 'th', alignments)]), 
			DOM.tbody({},rows.slice(1).map(
				function(row) { return renderRow(row, 'td', alignments); })));
	}
});

function fixSpaces(str) {
	return str.replace(/^ +|  +| +(?=\n|$)/, function(m,a,b) {
				return Array(m.length + 1).join('\u00A0');
			});
}

function isElement(o){
  return (
    typeof HTMLElement === "object" ? o instanceof HTMLElement : //DOM2
    o && typeof o === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName==="string"
	);
}

// render model to array of Friar components
function renderToFriar(model) {
	var rendered = [];
	var tokens = model.cells;
	var index = 0;
	var token;
	
	function getToken() {
		return token = tokens[index++];
	}

	function ungetToken() {
		return token = tokens[(--index)-1];
	}

	function renderSpans(item, para) {
		if (item.spans.length === 0) {
			return para ? [DOM.text('\u00A0'), DOM.br()] : [DOM.text('\u00A0')]; //id: keyToId(token.key)
		}
		return item.spans.map(function(c) {
			return DOM.text(fixSpaces(c.text)); //TODO: assmuing everything is text
		});
	}

	function renderRow(type, alignments) {
		return DOM.tr({id: keyToId(token.key)},token.values.map(function(c,i) { //
			return DOM[type]({style: (alignments[i] || {})}, c); //TODO (c should be spans)
		}));
	}

	function renderCode(lang) {
		var ret = []
		var items = [];
		var sitems = [];
		var langClass;
		do {
			var props = {id: keyToId(token.key)};//TODO: add key
			if (token.lang) langClass = props.className = 'lang-' + token.lang
			items.push(DOM.code(props,fixSpaces(token.text)));
			if (token.sexpr) {
				token.sexpr.forEach(function(sexpr) {
					sitems.push(DOM.code({className: 'lang-sexpr'}, Cube.showS(sexpr) + '\n'));
				});
			}
			if (token.result || token.error) {
				ret.push(DOM.pre({className: langClass}, items));
				items = [];
				if (sitems.length > 0) {
					ret.push(DOM.pre({className: 'lang-sexpr'}, sitems));
					sitems = [];
				}
				if (token.result) {
					try {
						var result = token.result();
						if (isElement(result)) {
							ret.push(DOM.div({className: 'result'}, [Friar.Wrap(result)]));
						} else {
							ret.push(DOM.div({className: 'result'}, result.toString()));
						}
					} catch(e) {
						token.error = e;
					}
				}
				if (token.error)
					ret.push(DOM.div({className: 'error'}, token.error.toString()));
			}
			getToken();
		} while (token && token.type === 'code' && token.lang === lang);
		ungetToken();
		if (items.length > 0)
			ret.push(DOM.pre({className: langClass}, items));
		if (sitems.length > 0)
			ret.push(DOM.pre({className: 'lang-sexpr'}, sitems));
		return ret
	}

	function renderList(listType, itemType) {
		var items = [];
		while (token && token.type === itemType) {
			items.push(DOM.li({id: keyToId(token.key)},renderSpans(token))); //TODO: add key
			getToken();
		}
		ungetToken();
		return [DOM[listType]({}, items)];
	}

	function renderFigure() {
		var f = token;
		return [DOM.figure({id: keyToId(token.key)},
			DOM.img({alt: f.alt, src: f.src}),
			DOM.figcaption({}, f.caption)
		)];
	}

	function renderPara() {
		switch (token.type) {
			case 'code':   return renderCode(token.lang);
			case 'p':      return [DOM.p({id: keyToId(token.key)}, renderSpans(token, true))];
			case 'header': return [DOM['h'+token.level]({id: keyToId(token.key)}, 
				fixSpaces(token.text))];
			case 'figure': return renderFigure();
			case 'ulli':   return renderList('ul', 'ulli');
			case 'olli':   return renderList('ol', 'olli');
			case 'quote':  return [DOM.blockquote({id: keyToId(token.key)}, renderSpans(token))];
			//case 'tr':     return renderTable();
			case 'table':  return [Table(token)];
			default: 
				return [
					DOM.p({className: 'error', id: keyToId(token.key)}, 
						"Error: Don't know what to do with a " + token.type)
				];
		}
	}

	function renderSection() {
		var children = [];
		getToken();
		while (token && token.type !== 'break') {
			Array.prototype.push.apply(children, renderPara());
			getToken();
		};
		return DOM.section({}, children);
	}

	while (index < tokens.length) {
		rendered.push(renderSection());
	}
	return rendered;
}

var Preview = createClass({
	render: function() {
		return DOM.div({id: 'preview', className: 'editor'}, 
			renderToFriar(this.props.model));
	}
});


var IgnoreKeys = {
	Shift: false,
	Win: false,
	Control: false,
	CapsLock: false,
	Alt: false,
	Meta: false,
	Left: true,
	Right: true,
	Up: true,
	Down: true,
};

var isOpera = !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;
    // Opera 8.0+ (UA detection to detect Blink/v8-powered Opera)
var isFirefox = typeof InstallTrigger !== 'undefined';   // Firefox 1.0+
var isSafari = Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;
    // At least Safari 3+: "[object HTMLElementConstructor]"
var isChrome = !!window.chrome && !isOpera;              // Chrome 1+
var isIE = /*@cc_on!@*/false || !!document.documentMode; // At least IE6


var canInsertText = document.queryCommandSupported('insertText');
var canMsUndo = document.queryCommandSupported('ms-beginUndoUnit');

function insertText(ta, str) {
	if (canInsertText && !isFirefox) {
		document.execCommand('insertText', false, str);
		return;
	}
	if (canMsUndo) document.execCommand('ms-beginUndoUnit');
	var val = ta.value;
	var start = ta.selectionStart;
	var end = ta.selectionEnd;
	ta.value = val.substring(0,start) + str + val.substring(end);
	ta.selectionStart = ta.selectionEnd = start + str.length;
	if (canMsUndo) document.execCommand('ms-endUndoUnit');
}

function pathFor(node, offset, model) {
	var path = [];
	while(!node.id && node.parentNode) {
		var i = 0;
		var no = node;
		while(no = no.previousSibling) { ++i; }
		path.push(i);
		node = node.parentNode;
	}
	var id = node.id;
	if (id === 'preview') {
		//selection.node offset
		console.log(focusPath + ' from preview');
	} else if (reKey.test(id)) {
		var key = id
			.slice(KEY_PREFIX.length)
			.split('.')
			.map(function(k) { return parseInt(k, 36); });
		var ind = model.indexOfKey(key[0]);
		if (ind === -1) {
			console.log('Key not found in model ' + id);
			return;
		}
			
		var cell = model.cells[ind];
		return model.offsetOfIndex(ind) + offsetInCell(cell, path, key, offset);
	}
	return 0;
}

function offsetInCell(cell, path, key, offset) {
	switch (cell.type) {
		case 'table': 
			var rowNum = key[1] || 0;
			for (var i = 0; i < rowNum; i++) {
				offset += cell.rows[i].raw.length + 1; //+1 for newline that gets removed from raw by split
			}
			var cellNum = path.pop(); //path is now span path
			for (var i = 0; i< cellNum; i++) {
				offset += cell.rows[rowNum].cells[i].length; //change to raw length when we span cell
			}
			offset += cellNum + 1; //add on pipes
			break;
		case 'header':
			offset += cell.level;
			break;
		case 'figure':
			var w = path.pop();
			if (w === 1) offset += cell.alt.length + cell.src.length + 5;
			else offset = cell.alt.length + cell.src.length + 5;
			break;
		case 'quote':
		case 'ulli':
		case 'olli':
			offset++;
			break;
		case 'code':
			offset += (cell.text.slice(0,offset).match(/\n/g) || []).length; //space per newline
			offset++; //inital space
			break;

	}
	return offset;
}

function nodeAtOffset(fullOffset, model) {
	var cello = model.cellForOffset(fullOffset);
	if (!cello) return;
	var cell = cello.cell;
	var offset = cello.offset;
	var baseKey = keyToId(cell.key);
	var baseElem = document.getElementById(baseKey);
	switch (cell.type) {
		case 'table':
			var rowNum = 0;
			for (var rowNum = 0; rowNum < cell.rows.length - 1; rowNum++) {
				var l = cell.rows[rowNum].raw.length + 1;
				if (offset < l) break;
				offset -= l;
			}
			var row = cell.rows[rowNum].cells;
			var cellNum;
			offset--;
			for (cellNum = 0; cellNum < row.length - 1; cellNum++) {
				var l = row[cellNum].length + 1;
				if (offset < l) break;
				offset -= l;
			}
			if (rowNum === 0) {
				baseElem = baseElem.firstChild.firstChild; //thead.tr
			} else {
				baseElem = baseElem.childNodes[1].childNodes[rowNum-1]; //tbody.tr;
			}
			baseElem = baseElem.childNodes[cellNum].firstChild;
			break;
		case 'p':
			baseElem = baseElem.firstChild;
			break;
		case 'header':
			offset -= cell.level;
			baseElem = baseElem.firstChild;
			break;
		case 'figure':
			var toff = 	cell.alt.length + cell.src.length + 5;
			if (offset >= toff) {
				offset -= toff;
				baseElem = baseElem.childNodes[1].firstChild;
			}
			break;
		case 'quote':
		case 'ulli':
		case 'olli':
			offset--;
			baseElem = baseElem.firstChild;
			break;
		case 'code':
			offset--;
			offset -= (cell.raw.slice(0,offset).match(/\n/g) || []).length; //space removed per newline
			baseElem = baseElem.firstChild;
			break;
	}
	return {node: baseElem, offset: offset};
}

function childOfId(node, id) {
	do {
		if (node.id == id) return true;
	} while (node = node.parentNode);
	return false;
}


var Selection = createClass({
	getInitialState: function() {
		return {
			selection: null,
		}
	},
	renderSelection: function(range) {
		var rects = range.getClientRects(),
			r = range.getBoundingClientRect()
		  , ret = []
		  , cs
		  , fbot
		  , rect
		  , farLeft = Math.floor(r.left)
		  , farRight = Math.ceil(r.right)
		  , scrollTop = document.documentElement.scrollTop || document.body.scrollTop
          , scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft
          , len = rects.length
          , i;
        if (len > 0) {
        	rect = rects[0];
        	cs = {
        		top: (rect.top + scrollTop) + 'px',
        		left: (rect.left + scrollLeft) + 'px',
        		height: rect.height + 'px',
        		width: (farRight - rect.left) + 'px',
        	}
			fbot = rect.bottom;
        	ret.push(DOM.div({style:cs, key:'first'}," "));
        }
        if (len > 1) {
        	rect = rects[len - 1];
        	cs = {
        		left: (farLeft + scrollLeft) + 'px',
        		width: (rect.right - farLeft) + 'px',
        	}
			var gap = rect.top - fbot;
			if (gap < rect.height * 0.6) {
				cs.top = (rect.top + scrollTop - gap) + 'px';
        		cs.height = (rect.height + gap) + 'px';
			} else {
        		cs.top = (rect.top + scrollTop) + 'px';
        		cs.height = rect.height + 'px';
        		// now draw the gap
        		ret.push(DOM.div({style: {
        			top: (fbot + scrollTop) + 'px',
        			left: (farLeft + scrollLeft) + 'px',
        			width: (farRight - farLeft) + 'px',
        			height: gap + 'px'
        		}, key: 'mid'}, " "));
			}
			ret.push(DOM.div({style: cs, key: 'last'}, " "));
        }
        return ret;
	},
	render: function() {
		var range = this.state.selection;
		if (range === null)
			return DOM.div({className: 'selection'});

		var rects = range.getClientRects(),
			scrollTop = document.documentElement.scrollTop || document.body.scrollTop,
        	scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;
        if (rects.length === 0)
        	return DOM.div({className: 'selection'});


		if (range.collapsed) {
			var rect = rects[0];
			var cs = {
				top: (rect.top + scrollTop) + 'px',
				left: (rect.right + scrollLeft - 1) + 'px',
				height: rect.height + 'px',
				display: 'block',
			}
			return DOM.div({className: 'selection'}, [DOM.span({className: 'cursor', style: cs},' ')]);
		} else {
			return DOM.div({className: 'selection'}, this.renderSelection(range)); //draw divs
		}
		
	},
});


var Editor = createClass({
	getInitialState: function() {
		var text = this.props.model.toRaw();
		return {
			text: text,
			selection: { focus: 0, anchor: 0 },
			//model: new Model(parseRaw(text)),
		};
	},
	updateText: function() {
		if (this.dontUpdate) return;
		
		var ta = this.textarea.node;
		console.log('updateText at ' + ta.selectionStart + ':' + ta.selectionEnd);
		
		var ta = this.textarea.node;
		var cur = this.state.selection;
		var text = ta.value;
		var hasTextChanged = (text != this.state.text);
		var hasSelectionChanged = !(ta.selectionStart == cur.anchor &&
			ta.selectionEnd == cur.focus)

		if (hasTextChanged && hasSelectionChanged) {
			this.props.update(this.props.name, text);
			this.setState({
				text: text, 
				selection: {anchor: ta.selectionStart, focus: ta.selectionEnd},
			});
		} else if (hasSelectionChanged) {
			this.setState({
				selection: {anchor: ta.selectionStart, focus: ta.selectionEnd},
			});
		} else if (hasTextChanged) {
			this.props.update(this.props.name, text);
			this.setState({
				text: text
			});
		}
	},
	handleMouseDown: function(e) {
		this.props.cursor.setState({selection: null});
	},
	handleMouseUp: function(e) {
		var selected = window.getSelection();
		if (selected.rangeCount !== 1)
			return;
		if (!childOfId(selected.anchorNode, 'preview') ||
			!childOfId(selected.focusNode, 'preview')) return;
		var range = selected.getRangeAt(0);
		var focus = pathFor(selected.focusNode, selected.focusOffset, this.props.model);
		var anchor = focus;
		if (!selected.isCollapsed) {
			anchor = pathFor(selected.anchorNode, selected.anchorOffset, this.props.model);
		}
		//check roundTrip
		var x = nodeAtOffset(focus, this.props.model);
		if (x && (x.node !== selected.focusNode || x.offset !== selected.focusOffset)) {
			console.log('WARNING: selection not round tripping');
			console.log(x);
			console.log({node: selected.focusNode, offset: selected.focusOffset});
		}
		
		//var ta = this.textarea.node;
		//We don't support inverted selections
		if (anchor > focus) {
			var temp = focus;
			focus = anchor;
			anchor = temp;
		}

		var cur = this.state.selection;
		if (anchor !== cur.anchor || focus !== cur.focus) {
			var sel = {anchor: anchor, focus: focus};
			this.updateCursor(sel)
			this.setState({selection: sel});
		}
		//if (anchor === focus) {
		
			this.dontUpdate = true;
			var ta = this.textarea.node;
			ta.focus();
			//this.dontUpdate = false;
			if (ta.setSelectionRange) ta.setSelectionRange(anchor, focus);
			this.dontUpdate = false;
		//}
		console.log('up ' + anchor + ' to ' + focus);
		
	},
	handleChange: function(e) {
		console.log('change');
		//if (!this.props.active) this.props.focus(this.props.name);
		this.updateText();
	},
	handleKeyDown: function(e) {
		console.log('keydown');
		this.updateText();
	},
	handleKeyUp: function(e) {
		console.log('keyup');
		this.updateText();
	},
	handleFocus: function(e) {
		console.log('focus');
		//if (!this.props.active) this.props.focus(this.props.name);
		this.updateText();
	},
	handleBlur: function(e) {
		console.log('blur');
		this.updateText();
	},
	handleInput: function(e) {
		console.log('input');
		//if (!this.props.active) this.props.focus(this.props.name);
		this.updateText();
	},
	didMount: function() {
		console.log('mounted');
		//TODO: this stuff should be on the actual textarea node itself
		//document.body.addEventListener('keydown', this.handleContentKeyDown);
		//document.body.addEventListener('keyup', this.handleContentKeyUp);
		this.textarea.node.value = this.state.text;
		this.textarea.node.selectionStart = this.textarea.selectionEnd = 0;
	},
	updateCursor: function(sel) {
		var sel = sel || this.state.selection;
		var anchor, focus;
		var range = document.createRange();
		anchor = focus = nodeAtOffset(sel.focus, this.props.model);
		if (sel.focus !== sel.anchor) {
			anchor = nodeAtOffset(sel.anchor, this.props.model);
		}

		try {
			if (anchor.offset < 0) {
				range.setStartBefore(anchor.node);
			} else {
				range.setStart(anchor.node, anchor.offset);
			}

			if (focus.offset < 0) {
				range.setEndBefore(focus.node);
			} else {
				range.setEnd(focus.node, focus.offset);
			}
		} catch(e) {
			console.log('Invalid range');
		}

		var rects = range.getClientRects(),
			scrollTop = document.documentElement.scrollTop || document.body.scrollTop,
        	scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;
        if (rects.length > 0) {
        	var rect = rects[0];
        	this.textarea.node.style.top = (rect.top + 5 + scrollTop) + 'px';
        }

		this.props.cursor.setState({selection: range});


	},
	didUpdate: function() {
		//console.log('updated');
		//console.log(this.selection);
		//TODO: set the selection and cursor positions.
		if (this.props.active) {
			this.dontUpdate = true;
			this.textarea.node.focus()
			this.dontUpdate = false;
			this.updateCursor(); 
		}
		
	},
	willUnmount: function() {
		console.log('unmounting');
	},
	render: function() {
		//console.log('render');
		//?? does this work when we are going with previous Child and updating
		this.textarea = DOM.textarea({
			//id: 'model', 
			className: 'hiddenTextArea', 
			//value: this.state.text,
			onKeyDown: this.handleKeyDown,
			onKeyUp: this.handleKeyUp,
			onFocus: this.handleFocus,
			onBlur: this.handleBlur,
			onChange: this.handleChange,
			onInput: this.handleInput,
		});
		//this.selection = Selection();
		var children = [this.textarea];

		if (this.props.active) {
			//children.push(this.selection);
			children.push(Preview({model: this.props.model}));
		}
		return DOM.div({
				className: 'content',
				onMouseUp: this.handleMouseUp,
				onMouseDown: this.handleMouseDown,
			},children);
	}
});

var text = "#Cube\n"
		 + "This is a paragraph\n"
		 + "|this|is|a|table\n"
		 + "|more|table|stuff|here\n"
		 +"Paragraph to separate tables\n"
		 + "|State[Row]|Gender[]|City[]|Pop[]\n"
		 + "|WA|M|Seattle|2\n"
		 + "|WA|F|Seattle|23\n"
		 + "|KS|M|Lawrence|4\n"
		 + "|KS|F|Lawrence|345\n"
		 + "|FL|M|Miami|546\n"
		 + "|FL|F|Miami|2\n"
		 + "|FL|M|Orlando|1000\n"
		 + "|FL|F|Orlando|2000\n"
		 + "Split the above table into two(2) parts and it should still work\n"
		 + "|State[Row]|Gender[]|City[]|Pop[]\n"
		 + "|OK|M|Ohio|2\n"
		 + "|OK|F|Ohio|23\n"
		 + "|MI|M|Indiana|4\n"
		 + "|MI|F|Indiana|345\n"
		 + "|KS|M|Kansas City|546\n"
		 + "|KS|F|Kansas City|2\n"
		 + "|FL|M|Tampa|1000\n"
		 + "|FL|F|Tampa|2000\n"
		 + "Alternative table format with a key\n"
		 + "|Portfolio=|Description[]|Weight[]\n"
		 + "|Equity|Equities|= 80%\n"
		 + "|UK|  UK Equities|= 70% * Weight[Portfolio=Equity]\n"
		 + "|EU|  European Equities|= 30% * Weight[Portfolio=Equity]\n"
		 + "|Bond|Global Bonds|= 20%\n"
		 + "||Unknown Portfolio|= 0\n"
		 + " Month[] = {Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec}\n"
		 + "Now we define Unit Sales\n"
		 + " Unit Sales[Month=Jan] = 5000\n Unit Sales = Unit Sales[Prev(Month)] * (1 + Growth)\n"
		 + "Some description here\n"
		 + " Assum[] = {\n"
		 + "  5000, 6000, 7000, 8000}\n"
		 + " function something() {\n"
		 + "   //this is some javascript that gets automatically detected.\n"
		 + " }\n"
		 + " Growth[] = {1%,2%}\n Graph.Line(Unit Sales[Month][Growth])\n"
		 + "This is a paragraph\n"
		 + "*This is a list item\n"
		 + "*this is another list item\n"
		 + ".This is a numbered list item\n"
		 + ".This is another numbered list item\n"
		 + "This is another paragraph\n"
		 + "##This is a sub header\n"
		 + "This is a paragraph with *bold* text and _italic_ text in it\n"
		 + "This is a paragraph with a link [this is link text][1].\n"
		 + ">This is a blockquote\n"
		 + "-"
		 + "The dash before a paragraph is a section break (that might be rendered as an hr - note.. change so it doesn't need to be on its own line but can live before a paragraph or other element)\n"
		 + "![alt text](css/fonts/glyphicons-halflings.png)figure text here\n"
		 + "Idea ... use non printing characters to stand in for bold and italics and links in the code so that you don't have extra characters to delete or insert in those cases. This might not help much. It might be easier to just store the list and manage it based on keypresses.\n"
		 + "There is an empty paragraph at the end after this one. ⊕\n"
		 + "\n"
		 + "[1](http://google.co.uk \"Google\")\n"
		 + " import(\"Test1\")\n import(\"Test2\")\n import(\"TestMe\")";


var MultiEditor = createClass({
	getInitialState: function() {
		return {
			active: this.props.active,
			debug: false,
		};
	},
	handleMenuClick: function(e) {
		console.log('clicked');
		//e.preventDefault();
		//e.stopPropagation();
		if (e.target.hash) {
			this.setState({active: e.target.hash.slice(1)});
		}
	},
	updateModel: function(name, text) {
		this.props.cube.mergeModel(name, parseRaw(text));
		//trigger redraw?
		this.setState({active: name});
	},
	toggleDebug: function() {
		this.setState({debug: !this.state.debug});
	},
	save: function() {
		console.log('save clicked')
	},
	revert: function() {
		console.log('revert clicked')
	},
	render: function() {
		var me = this;
		var active = this.state.active || 0;
		var cursor = this.props.cursor;
		var cube = this.props.cube;
		return DOM.div({id: 'layout'},
			DOM.a({href: '#menu', id: 'menuLink', className: 'menu-link'}, [DOM.span()]),
			DOM.div({id: 'menu'}, 
				[DOM.div({className:"pure-menu pure-menu-open"},
					DOM.a({className:"pure-menu-heading", href:"#"},'Cube'),
					DOM.ul({}, cube.names.map(function(n,i) {
						return DOM.li({onClick: me.handleMenuClick, className: (n === active ? 'pure-menu-selected ' : '') + (cube.models[n].modified ? 'menu-modified' : '') },
							[DOM.a({href:"#" + n}, n)])
					})),
					DOM.ul({}, [DOM.li({onClick: me.handleMenuClick, 
						className: ('#Scratch' === active ? 'pure-menu-selected' : '') },
							[DOM.a({href:"##Scratch"}, 'Scratch')])]),
					DOM.ul({}, [DOM.li({onClick: this.toggleDebug},
							[DOM.a({href:"#"}, 'Debug')]),
							DOM.li({onClick: this.save},
							[DOM.a({href:"#"}, 'Save')]),
							DOM.li({onClick: this.revert},
							[DOM.a({href:"#"}, 'Revert')]),
					])
					)]),
			DOM.div({id: 'main', className: (this.state.debug ? 'show-debug' : '') }, 
				mapObjToArr(cube.models, function(name, value) {
				return Editor({
					model: value,
					active: name === active,
					name: name,
					cursor: cursor,
					update: me.updateModel,
				}); 
			}))
		);
	}
});


function mapObjToArr(obj, func) {
	var ret = [];
	for (var k in obj) {
		if (obj.hasOwnProperty(k)) ret.push(func(k, obj[k]));
	}
	return ret;
}

var cube = new Cube();

var dummy = {
	Test1: parseRaw("#Test1\nThis is some test text\n import(\"TestFred\")\n 1 + 2 + 3"),
	Test2: parseRaw("#Test2\nMore text here\n And some code\n"),
	Main: parseRaw(text),
};
Cube.Import = function(path) {
	return dummy[path];
};

cube.import('Main');
cube.recalculate();
var cursor = new Selection();
Friar.renderComponent(cursor, document.getElementById('cursor'));
var x;
Friar.renderComponent(x = new MultiEditor({cursor: cursor, cube: cube, active: cube.names[0] || '#Scratch'}), document.getElementById('view'))
//Friar.renderComponent(x = new Editor({text: text, active: true}), document.getElementById('main'));

/*
var O = {}
var A = O.A = function() { return 10; }
var B = O.B = function() { return 11; }
var C = O.C = function() { return 12; }

function Plus(a, b) { 
	return function() {	return a() + b(); };
}

O.Clo = Plus(Plus(O.A,O.B),O.C);
O.Fun = (new Function(['a','b','c'],
 'return function() { return (a() + b()) + c(); };'))(O.A,O.B,O.C); //if we do the full 
O.FunI = new Function('var me = this; return (me.A() + me.B()) + me.C()');
O.FunII = (new Function(['Ob'],
	'var A = Ob.A, B = Ob.B, C = Ob.C; return function () { return (A() + B()) + C(); };'))(O);
O.Eval = eval('(function() { return A() + B() + D(); })');


function D() { return 12; }

console.log(O.Clo());
console.log(O.Fun());
console.log(O.FunI());
console.log(O.FunII());
console.log(O.Eval());

function test(n) {
	console.time('Clo');
	for (var i = 0; i < n; i++) O.Clo();
	console.timeEnd('Clo');
	
	console.time('Fun');
	for (var i = 0; i < n; i++) O.Fun();
	console.timeEnd('Fun');

	console.time('FunI');
	for (var i = 0; i < n; i++) O.FunI();
	console.timeEnd('FunI');

	console.time('FunII');
	for (var i = 0; i < n; i++) O.FunII();
	console.timeEnd('FunII');

	console.time('Eval');
	for (var i = 0; i < n; i++) O.Eval();
	console.timeEnd('Eval');
}
*/

</script>
<script src="js/ui.js"></script>
</body>
</html>