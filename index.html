<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<meta http-equiv="Content-Type" content="application/xhtml+xml">
	<title></title>
	<script src="http://code.jquery.com/jquery-1.10.0.min.js"></script>
<link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,700|Inconsolata" />
<link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.5.0/pure-min.css"/>

<!--[if lte IE 8]>
    <link rel="stylesheet" href="css/layouts/side-menu-old-ie.css">
<![endif]-->
<!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="css/layouts/side-menu.css">
<!--<![endif]-->


<script src="js/clay.js"></script>
<script src="js/parser.js"></script>
<link rel="stylesheet" href="css/clay.css"/>
<style type="text/css">
.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.x.axis path {
  display: none;
}

.line {
  fill: none;
  stroke: steelblue;
  stroke-width: 1.5px;
}
</style>
</head>

<body>
<div class='debug'>
<div class='content'>
<textarea id="model" class="editor pure-u-5-5">
# Clay

Requires Chrome, Firefox, or IE9>.
</textarea>	
</div>
</div>
<div id="layout">
    <!-- Menu toggle -->

    <div id="main">
<div class="content">
	
<div id="preview" class="editor">
</div>
</div>
</div>
</div>
<script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.6.0/underscore-min.js"></script>
<script type="text/javascript" src="js/react/react-with-addons.js"></script>
<script type="text/javascript" src="js/functions.js"></script>
<script src="http://d3js.org/d3.v3.js"></script>
<script type="text/javascript">
var title = "Clay"
var DOM = React.DOM,
	div = DOM.div, ul = DOM.ul, li = DOM.li, p = DOM.p
	h1 = DOM.h1, h2 = DOM.h2, a = DOM.a, span = DOM.span;


function isElement(o){
  return (
    typeof HTMLElement === "object" ? o instanceof HTMLElement : //DOM2
    o && typeof o === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName==="string"
);
}

//helper string functions
if (typeof String.prototype.startsWith != 'function') {
  String.prototype.startsWith = function (str){
    return this.slice(0, str.length) == str;
  };
}

var _defaultPakageName = 'Main';

var Model = function(name, source) {
	this.name = name;
	this.source = this.originalSource = source.replace(/\r\n/g,'\n');
	this.package = _defaultPakageName
	this.expressions = {};
	this.functions =  {};
	this.properties = {}; //meta
	this.ast = {type: 'root', children: []};
	this.packages = [this.package];
	this.recalculate();
};

Model.prototype.isModified = function() {
	return this.source != this.originalSource;
};

Model.prototype.update = function(source) {
	var s = source.replace(/\r\n/g,'\n');
	if (s != this.source) {
		this.source = s;
		this.recalculate();
	}
};

Model.prototype.revert = function() {
	if (this.originalSource != this.source) {
		this.source = this.originalSource;
		this.recalculate();
	}
};


var makeRecursion = function(func) {
	return function(expr) {
		var head = expr[0];
		if (head == 'Symbol') {
			return ['Let', ['Index', expr], func(expr)];
		};
		if (head == 'Subtract' || head == 'Plus') {
			var lhs = expr[1], rhs = expr[2];
			if (lhs[0] == 'Symbol' && rhs[0] == 'Number') {
				return ['Let', ['Index', lhs], [head, func(lhs), rhs]];
			}
		}
	}
}

//TODO: this needs to take a prec so we can
// avoid too many brackets in output.
function showMr(s) {
	switch (s[0]) {
		case 'Number': return s[1].toString();
		case 'String': return s[1];
		case 'Symbol': return s.slice(1).join('.');
		case 'List':   return '{' + s.slice(1).map(showMr).join(', ') + '}';
		case 'Slice':  return showMr(s[1]) + '[' + s.slice(2).map(showMr).join(', ') + ']';
		case 'Call':   return showMr(s[1]) + '(' + s.slice(2).map(showMr).join(', ') + ')';
		case 'Set':
		case 'Set*':
		case 'Let': return showMr(s[1]) +'=' + showMr(s[2]);
		case 'Plus': return '(' + s.slice(1).map(showMr).join(' + ') + ')';
		case 'Times': return '(' + s.slice(1).map(showMr).join(' * ') + ')';
		case 'Subtract': return '(' + s.slice(1).map(showMr).join(' - ') + ')';
		case 'Divide': return '(' + s.slice(1).map(showMr).join(' / ') + ')';
		//TODO: make the infix check 
		default: return clay.code.show(s);
	};
}

var showM = function(s) {
	return ['String', showMr(s)];
};

//This should only be called at the base level
// as Flip(X, Line, {Net Income, etc})
// or X = Flip(Line, {Net Income, etc})
var flip = function(symb, catSymb, expr) {
	if (expr[0] !== 'List')
		return ['Error', 'Flip joins a list of expr', sexpr];
	var qexpr = ['List'];
	expr.slice(1).forEach(function(s) {
		qexpr.push(showM(s));
	});
	var cat = ['Category', catSymb, qexpr];
	var func = ['Set*', symb, ['Indexed*', expr, ['Index', catSymb]]]; //need Indexed* and Set* to not do memo
	return ['Do', cat, func]; //Do A B is same as A\nB
};

var table = function(expr, opt_dims) {
	if (expr[0] !== 'List') {
		expr = ['List', expr];
	}
	var quoteds = expr.map(function(e, i) { return (i > 0) ? showM(e) : e });
	var pm = ['PostMacro', ['Symbol', 'Table'], expr, quoteds];
	if (opt_dims !== undefined) {
		pm.push(opt_dims);
	}
	return ['NoDim', pm]; 
};

//Table({Graph.Line(Net Income[Month][Growth]*Year)})
//Table({Graph.Line(Net Income[Month][Growth])})
//Table({Graph.Line(Net Income[Month][Growth])},{Year})
//Y = Table({Graph.Line(Net Income[Month][Growth])})
var postTable = function(exprs, quoteds, dims) {
	//exprs and quoteds are both expected to be list literals
	//TODO.. implement
	//Lookup dimensions of expression
	//var dims = .map(function(d) { 
	//	var s = d.split('.'); s.unshift('Symbol'); return s; });
	//quote them
	//put length where 1 is.
	if (dims === undefined) {
		dims = exprs.dimensions;
	} else {
		dims = dims.slice(1).map(function(d) { 
			return d.dimensions[0]; }
		);
	}

	var len = ['Number', dims.length];
	//BasicTable({"Year","Graph.Line(Net Income[Month])"},{Year,Graph.Line(Net Income[Month][Growth])}[Year],1)
	var heads = ['List'];
	heads.dimensions = []
	var fexpr = ['List'];
	fexpr.dimensions = dims;
	if (dims.length > 0)
		var over = ['Over', fexpr];
	else
		var over = ['List', fexpr];
	over.dimensions = [];
	dims.forEach(function(d) { 
		var s = d.split('.'); 
		s.unshift('Symbol');
		s.dimensions = [d];
		fexpr.push(s); over.push(s); heads.push(['String', s[2]]); 
	});
	exprs.slice(1).forEach(function(d) { fexpr.push(d); });
	quoteds.slice(1).forEach(function(d) { heads.push(d); });
	return ['Call', ['Symbol', 'BasicTable'], heads, over, len]; 
};

//pages should be of form {symb=value,...}
var pivot = function(expr, pages, cols, rows, descriptions) {
	return ['NoDim', ['PostMacro', ['Symbol', 'Pivot'], expr, 
		showM(expr), pages, cols, rows, descriptions]]; 
};

var postPivot = function(expr, quoted, pages, cols, rows, descriptions) {
	//TODO: .. implement this
	return ['Call', ['Symbol', '_Pivot'], showM(expr), expr]; 
};

var quoteM = function(expr) {
	return showM(expr);
};

var expand = function(expr) {
	return expandMacros(expr);
};

var quoteS = function(expr) {
	return clay.code.show(expr);
};

var nodim = function(expr) {
	return ['NoDim', expr];
};

//most macros are applied before 
var Macros = {
	PREV: makeRecursion(function(symb) { return ['Subtract', ['Index', symb], ['Number', 1]];}),
	NEXT: makeRecursion(function(symb) { return ['Plus', ['Index', symb], ['Number', 1]];}),
	THIS: makeRecursion(function(symb) { return ['Index', symb];}),
	FIRST: makeRecursion(function(symb) { return ['Number', 0];}),
	LAST: makeRecursion(function(symb) { return ['Subtract', ['Count', symb], ['Number', 1]];}),
	TABLE: table,
	PIVOT: pivot,
	QUOTE: quoteM,
	QUOTES: quoteS,
	EXPAND: expand, //usage Expand(QuoteS(...))
	NODIM: nodim,
	FLIP: flip,
};

//macros applied after analyse dimensions
// cannot be used in definitions as they 
// change the dimensions
var PostMacros = {
	TABLE: postTable,
	PIVOT: postPivot,
}


var expandMacros = function(expr, path) {
	var symb, rep;
	
	if (expr[0] !== 'Call')
		return expr;

	var symb = expr[1];
	
	if (symb[0] !== 'Symbol' || 
		symb.length !== 2 || 
		!Macros.hasOwnProperty(symb[1].toUpperCase()))
		return expr;

	rep = Macros[symb[1].toUpperCase()].apply(this, expr.slice(2));

	if (rep !== undefined) {
		rep.originalSexpr = (expr.originalSexpr !== undefined) ? expr.originalSexpr : expr
		return rep;
	}

	return expr;
};

var expandPostMacros = function(expr) {
	var symb, rep;
	
	if (expr[0] !== 'PostMacro')
		throw new Exception('Cannot expand non post macro' + clay.code.show(expr));

	var symb = expr[1];
	
	if (symb[0] !== 'Symbol' || 
		symb.length !== 2 || 
		!PostMacros.hasOwnProperty(symb[1].toUpperCase()))
		return expr;

	rep = PostMacros[symb[1].toUpperCase()].apply(this, expr.slice(2));

	if (rep !== undefined) {
		rep.originalSexpr = (expr.originalSexpr !== undefined) ? expr.originalSexpr : expr
		return rep;
	}

	return expr;
};


var expandSlice = function expandSlice(expr, path) {
	var ret;
	switch(expr[0]) {
		case 'Slice': {
			var ret = expr[1], overs = ['Over', 0];
			for (var i = expr.length - 1; i >= 2; i--) {
				var para = expr[i];
				switch(para[0]) {
					case 'Let':
						ret = expandSlice(['LetS', para[1], para[2], ret], path);
						break;
					case 'Symbol':
						overs.push(para);
						break;
					default:
						ret = ['Restrict', para, ret];
				};
			}
			//wrap over on the outside
			if (overs.length > 2) {
				overs[1] = ret;
				ret = overs;
			}
			break;
		}
		case 'LetS': {
			//(LetS symb value expr) -> (LetS (Index symb) (IndexOf symb value) expr)
			if (expr[1][0] === 'Symbol')
			{
				var symb = expr[1], value = expr[2], exp = expr[3];
				ret = ['LetS', ['Index', symb], ['IndexOf', symb, value], exp];
			}
			break;
		}
		case 'Guards': {
			var ret = expr[1], overs = ['Indexed', 0];
			for (var i = expr.length - 1; i >= 2; i--) {
				var para = expr[i];
				if (para[0] === 'Symbol')
					overs.push(['Index', para]);
			};
			//wrap indexed on the inside
			if (overs.length > 2) {
				overs[1] = ret;
				ret = overs;
			}
			for (var i = expr.length - 1; i >= 2; i--) {
				var para = expr[i];
				switch(para[0]) {
					case 'Let':
						ret = ['LetG', para[1], para[2], ret];
						break;
					case 'Symbol':
						break;
					default:
						ret = ['Restrict', para, ret];
				};
			}
			break;
		}
	}
	if (ret !== undefined) {
		ret.originalSexpr = (expr.originalSexpr !== undefined) ? expr.originalSexpr : expr;
		return ret;
	}

	return expr;
};

Model.prototype.recalculate = function() {
	var lex = clay.lexer(this.source);
	this.ast.children = clay.parser(lex);
	//collect properties, code, tables
	var properties = {}, code = [], tables = [], functions = {}, expressions = {}, packages = {};
	depthFirstVisit(this.ast, function(node, depth, parent, idx) {
		var nodetype = node.type
		if (nodetype === 'meta') {
			if (properties.hasOwnProperty(node.head)) {
				//insert an error into the ast after the node.
				parent.children[idx] = {type: 'error', pos: node.pos,
					text: 'Property {' + node.head + '} already defined as: ' + properties[node.head],
					children: [node]};
			} else {
				properties[node.head] = node.value;
			}
			return true; // don't recurse to children
		} else if (nodetype === 'code' || nodetype === 'codespan') {
			code.push(node);
		} else if (nodetype === 'table') {
			tables.push(node);
		}
	});
	this.properties = properties;
	this.package = this.properties['package'] || _defaultPakageName;
	packages[this.package] = true;
	var basepack = this.package;
	var normaliseHead = function(n) { return clay.code.normaliseHead(n, basepack); };
	//TODO: Create functions from tables

	for (var i = 0; i < code.length; i++) {
		var node = code[i];
		node.sexpr = clay.code(node.code, this.package);

		//expand macros
		var sexpr = []
		node.sexpr.forEach(function(expr) {
			//TODO: try catch for errors in macro expansion
			var nodes = clay.code.transform(expr, expandMacros);
			if (nodes[0] === 'Do') {
				nodes = nodes.slice(1);
				//nodes.forEach(function(n) { n.originalSexpr = expr; })
				Array.prototype.push.apply(sexpr, nodes.map(normaliseHead));
			} else {
				sexpr.push(nodes);
			}
		});
		node.sexpr = sexpr;

		node.sexpr = node.sexpr.map(function(expr) {
			var nexpr = clay.code.transform(expr, expandSlice);
			//nexpr.originalSexpr = (expr.originalSexpr !== undefined) ? expr.originalSexpr : expr;
			return nexpr;
		});

		//collect packages referenced
		node.sexpr.forEach(function(f) {
			clay.code.visit(f, function(ast, path, index) {
				switch (ast[0]) {
					case 'Symbol':
						//namespace except for function calls
						//does not support nested namespaces
						if (ast.length === 3 && !(index === 1 && path[path.length-1] == 'Call')) {
							packages[ast[1]] = true;
						}
						break;
				}
			});
		});

        node.sexpr.forEach(function(sexpr, index) {
        	sexpr.sourceNode = node;
        	switch(sexpr[0]) {
        		case 'Set*':
        		case 'Set':
        			if (sexpr[1][0] !== 'Symbol') {
        				node.sexpr[index] = ['Error', 'Cannot Set ', sexpr[1]];
        			} else {
        				var fkey = sexpr[1].slice(1).join('.');
        				if (!functions.hasOwnProperty(fkey)) {
        					functions[fkey] = [(sexpr[0] === 'Set*' ? 'Func*' : 'Func'), sexpr[1]];
        				}
        				functions[fkey].push(sexpr[2]); //just rhs
        			}
        			break;
        		case 'Category':
        			if (sexpr[1][0] !== 'Symbol') {
        				node.sexpr[index] = ['Error', 'Cannot create Category ', sexpr[1]];
        			} else {
        				var fkey = sexpr[1].slice(1).join('.');
        				if (!functions.hasOwnProperty(fkey)) functions[fkey] = sexpr;
        				else node.sexpr[index] = ['Error', 'Cannot redefine Category ', sexpr[1]];
        			}
        			break;
        		case 'Rule':
        			node.sexpr[index] = ['Error', 'Rules not implemented', sexpr];
        			break;
        		default:
        			//expression
        			var ekey = clay.code.show(sexpr);
        			if (!expressions.hasOwnProperty(ekey))
        					expressions[ekey] = sexpr;
        	}
        });
        node.result = clay.code.show(node.sexpr);
	}
	this.functions = functions;
	this.expressions = expressions;
	this.packages = [];
	for (var p in packages) {
		if (packages.hasOwnProperty(p))
			this.packages.push(p);
	}
};


Model.prototype.charOffset = function(path, toff) {
	var node = this.ast, path = path.reverse(), cur, off = 0, row;
	while ((cur = path.pop()) !== undefined) {
		if (cur === '_') continue;
		else if (cur === 'result') return node.pos + node.length; //off + // no toff
		node = node.children[cur];
		if (node === undefined) return off + toff;
		off = node.pos; //+= //change pos to be against level
		if (node.type === 'table') {
			switch(cur = path.pop()) {
				case 'body':
					row = path.pop();
					cur = path.pop();
					node = {children: node.cells[row][cur]};
					break;
				case 'head':
					row = path.pop(); //should be 0
					cur = path.pop();
					if (row === 'align') {
						off = node.align.pos;
						for (var i = 0; i < cur; i++) {
							off += node.alignText[i].length + 1;
						}
						return off + toff;
					} else {
						node = {children: node.header[cur]};
					}
					break;
				//case 'foot': 
				//	return off + toff; //TODO: don't support foot yet
			}
		}
	}
	return off + toff;
};

var Blank = new Model('Blank', '# Blank\n\nEnter your model here.');

//f should return undefined to visit children
// false to skip rest of tree
// any other value to just skip children
function depthFirstVisit(node, f, depth, parent, index) {
	if (depth === undefined) depth = 0;
	var r = f(node, depth, parent, index);
	if (r === undefined && node.hasOwnProperty('children')) {
		depth += 1;
		var i, cs = node.children, l = cs.length;
		for (i = 0; i < l; i++) {
			if (depthFirstVisit(cs[i],f, depth, node, i) === false) {
				return false;
			}
		}
	}
	return r;
}


var camelCase = function(name) {
	return (name
		.toLowerCase()
		.replace(/[^a-zA-Z]+([a-zA-Z]|$)/g,
			function(s,m) { return m.toUpperCase(); }));
};

var joinComma = function(items) { return Array.prototype.join.call(items, ','); };

//memoize assumes indirect recursion
var memoize = function(func, hasher) {
	hasher = (hasher !== undefined) ? hasher : joinComma;
	var memo = function() {
		var cache = memo.cache, args = hasher(arguments);
		if (cache[args] === undefined)
			cache[args] = memo.func.apply(this, arguments);
		return cache[args];
	}
	memo.func = func; //so we can replace the func
	memo.clearCache = function() { memo.cache = {}; };
	memo.cache = {};
	return memo;
};

//place to store dependedOn
var unmemoize = function(func) {
	var memo = function() {
		return memo.func.apply(this, arguments);
	}
	memo.func = func; //so we can replace the func
	memo.clearCache = function() { };
	return memo;
};

var indexed = function(func) {
	var memo = function(i) {
		if (memo.cache === undefined)
			memo.cache = memo.func.apply(this);
		return memo.cache[i];
	};
	memo.func = func; //so we can replace the function
	memo.clearCache = function() { memo.cache = undefined; }
	memo.cache = undefined;
	memo.len = function() { 
		if (memo.cache === undefined)
			memo.cache = memo.func.apply(this);
		return memo.cache.length;
	};
	memo.forEach = function(f) {
		if (memo.cache === undefined)
			memo.cache = memo.func.apply(this);
		memo.cache.forEach(f);
	};
	memo.indexOf = function(v)  {
		if (memo.cache === undefined)
			memo.cache = memo.func.apply(this);
		return memo.cache.indexOf(v); //TODO: cache the index of
	};
	return memo;
};


var Clay = function() {
	this.models = [Blank];
	this._models = {'Blank': Blank};
	this._environment = new Environment();
	this._packages = {};
	this._genSyms = {};
	this._genSymCount = {};
};

Clay.prototype.Symbol = function(val) {
	if (this._genSyms[val] !== undefined)
		return this._genSyms[val];
	var hint = camelCase(val);
	if (this._genSymCount.hasOwnProperty(hint)) {
		this._genSyms[val] = hint + '_' + this._genSymCount[hint];
		this._genSymCount[hint] += 1;
	} else {
		this._genSymCount[hint] = 1;
		this._genSyms[val] = hint;
	}
	return this._genSyms[val];
};

var Graph = {};

Graph.Line = function(matrix, x, series) {
	var elem = document.createElement('div');

	d3.select(elem).attr("style", "width: 100%; min-width: 400px; min-height: 250px;")

// DUMMY graph to test the result concept

	var margin = {top: 20, right: 30, bottom: 30, left: 30},
    width = 800 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;

var parseDate = d3.time.format("%Y%m%d").parse;

var x = d3.time.scale()
    .range([0, width]);

var y = d3.scale.linear()
    .range([height, 0]);

var color = d3.scale.category10();

var xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom");

var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left");

var line = d3.svg.line()
    .interpolate("basis")
    .x(function(d) { return x(d.date); })
    .y(function(d) { return y(d.temperature); });

var svg = d3.select(elem).append('svg')
	//.attr("height", height + margin.top + margin.bottom)
	.attr("style", "width: 100%;")
	.attr("viewBox", "0 0 " + (width + margin.left + margin.right) + " " + (height + margin.top + margin.bottom))
    //.attr("width", width + margin.left + margin.right)
    
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

d3.tsv("data.tsv", function(error, data) {
  color.domain(d3.keys(data[0]).filter(function(key) { return key !== "date"; }));

  data.forEach(function(d) {
    d.date = parseDate(d.date);
  });

  var cities = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {date: d.date, temperature: +d[name]};
      })
    };
  });

  x.domain(d3.extent(data, function(d) { return d.date; }));

  y.domain([
    d3.min(cities, function(c) { return d3.min(c.values, function(v) { return v.temperature; }); }),
    d3.max(cities, function(c) { return d3.max(c.values, function(v) { return v.temperature; }); })
  ]);

  svg.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(0," + height + ")")
      .call(xAxis);

  svg.append("g")
      .attr("class", "y axis")
      .call(yAxis)
    .append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", 6)
      .attr("dy", ".71em")
      .style("text-anchor", "end")
      .text("Net Income");

  var city = svg.selectAll(".city")
      .data(cities)
    .enter().append("g")
      .attr("class", "city");

  city.append("path")
      .attr("class", "line")
      .attr("d", function(d) { return line(d.values); })
      .style("stroke", function(d) { return color(d.name); });

  city.append("text")
      .datum(function(d) { return {name: d.name, value: d.values[d.values.length - 1]}; })
      .attr("transform", function(d) { return "translate(" + x(d.value.date) + "," + y(d.value.temperature) + ")"; })
      .attr("x", 3)
      .attr("dy", ".35em")
      .text(function(d) { return d.name; });
});

	return elem;
};


Clay.prototype.evaluate = function(package, expression) {
	//TODO: replace this with real expression evaluation.
	var e = clay.code.show(expression);
	var exps = this._packages[package].expressions;
	if (exps.hasOwnProperty(e)) {
		try {
			//TODO: need to know the dimensions and type of the expression first
			return exps[e].compiled();
		} catch(ex) {
			console.log(e + ' resulted in ' + ex.message);
		}
	}
	return null;
};

Clay.prototype.model = function(name) {
	return this._models[name];
};

//Package is the ast representation of a Namespace
var Package = function(name) {
	this.name = name;
	this.dimensions = {};
	this.functions = {};
	this.expressions = {};
	this.unsatisfieds = {}; //dimensions that have no function
};

var Environment = function() {
	//Dummy object to store all the functions
	//and from which all the namespaces inherit
};

Environment.prototype.Math = Math;

Environment.prototype.Graph = {
	Line: Graph.Line,
};

Environment.prototype.Sum = function(list) {
	var sum = 0;
	list.forEach(function(v,i) { if (v !== undefined) sum += v; });
	return sum;
};


Environment.prototype.Max = function(list) {
	var max;
	list.forEach(function(v,i) { 
		if (max === undefined || max < v) max = v; 
	});
	return max;
};

Environment.prototype.Head = function(list) {
	var head;
	list.some(function(v,i) { head = v; return true;});
	return head;
};

Environment.prototype.Unique = function(list) {
	var included = {}, ret = [];
	list.forEach(function(v, i) {
		if (!included.hasOwnProperty(v)) {
			ret.push(v);
			included[v] = true;
		}
	});
	return ret;
};

Environment.prototype._Table = function(list, ast) {
	//TODO: use the ast to figure out the table.
	return clay.code.show(ast);
};

Environment.prototype.BasicTable = function(headers, rows, highlight) {
	var c = document.createElement.bind(document);
	var table = c('table'), head = table.createTHead(), body = table.createTBody();
	table.className = 'pure-table pure-table-horizontal';
	if (highlight === undefined) highlight = 0;

	var hr = head.insertRow();

	headers.forEach(function(h, i) {
		var th = c('th');
		hr.appendChild(th);
		if (i < highlight) th.className = 'highlight';
		if (isElement(h)) {
			th.appendChild(h);
		} else {
			th.appendChild(document.createTextNode(h.toString()));
		}
	});

	rows.forEach(function(r, j) {
		var tr = body.insertRow();
		r.forEach(function(e, i) {
			var th = tr.insertCell(-1);
			if (i < highlight) th.className = 'highlight';
			if (isElement(e)) {
				th.appendChild(e);
			} else {
				th.appendChild(document.createTextNode(e.toString()));
			}
		});
	});

	return table;
}

//Table({Math.round(Net Income), Tax, Revenue})
// returns only defined values
Environment.prototype.Values = function(list) {
	return list.filter(function() { return true; });
};


Clay.prototype.compileOver = function(expr, basepack) {
	var me = this;
	var exp = this.compileExpr(expr[1], basepack);
	var dims = expr.dimensions.map(function(d) {
		return me.Symbol(d);
	}).join(', ');
	var retDims = expr.slice(2).map(function(e) { 
		return '"' + e.dimensions[0] + '"'; });
	var overs = expr.slice(2).map(function(e) { 
		var pack = e.dimensions[0].split('.',1)[0];
		var name = e.dimensions[0].slice(pack.length+1);
		return {pack: pack,
				name: name,
				sym: me.Symbol(e.dimensions[0]) ,
			};
		});

	var vars = '    var _k0m = 1'
	var ends = [];
	var starts = [];
	var indexes = [];
	overs.forEach(function(o, i) {
		var obj = 'this["' + o.pack + '"]["' + o.name + '"]';
		indexes.push('_k' + (i+1));
		vars = vars + ', _k' + (i+1) + ', _k' + (i+1) +
		'm = _k'+ i +'m * ' + obj +'.len()'; //.len must be defined on category
		starts.push(obj + '.forEach(function(v, ' + o.sym + ') {\n\
        _k' + (i+1) + ' = _k' + i +'m * ' + o.sym + ';');
		ends.push('}.bind(this))');
	});
	var t = dims.length	> 0 ? 'this, ' : 'this'
	var ov = '(function(' + dims + ') { var _ret=[], _val;\n\
' + vars + ';\n\
    ' + starts.join('\n    ') + '\n\
        _val = '+exp+';\n\
        if (_val !== undefined) _ret['+ indexes.join(' + ') +'] = _val;\n\
    ' + ends.join('') +';\n\
    _ret.dimensions = ['+ retDims.join(', ') +'];\n\
    return _ret; \n\
}.call('+ t + dims + '))';
	return ov;
};

var quote = function quote(expr) {
	if (expr instanceof Array) {
		return '[' + expr.map(function(e) { return quote(e); }).join(', ') + ']';
	} 
	switch(typeof(expr)) {
		case 'string': return "'" + expr + "'";
		case 'number': return expr.toString();
		default: return expr.toString();
	};
}

Clay.prototype.compileExpr = function(expr, basepack) {
	var me = this;
	switch(expr[0]) {
		case 'PostMacro':
			return me.compileExpr(expandPostMacros(expr), basepack);
		case 'Category':
			return 'return (' + me.compileExpr(expr[2], basepack) + ');';
		case 'Func*':
		case 'Func':
			var exprs = expr.slice(2).map(function(e) {
				return '_ret = (' + me.compileExpr(e, basepack) + ');'
			});
			var ov = 'var _ret;\n\
' + exprs.join('\nif(_ret !== undefined) return _ret;\n') + '\n\
return _ret;'
			return ov;
		case 'NoDim':
			return me.compileExpr(expr[1], basepack);
		case 'Quote':
			return quote(expr[1]);
		case 'LetG':
			return '('+ me.compileExpr(expr[1], basepack) +' == '+ me.compileExpr(expr[2], basepack)+') ? (' + me.compileExpr(expr[3], basepack) + ') : undefined';
		case 'LetS':
			return '(function(' + me.compileExpr(expr[1], basepack) + ') { \nreturn ('+ me.compileExpr(expr[3], basepack) +'); \n}.call(this, '+me.compileExpr(expr[2], basepack)+'))';
		case 'Restrict':
			return '('+ me.compileExpr(expr[1], basepack) +') ? (' + me.compileExpr(expr[2], basepack) + ') : undefined';
		case 'Call':
			return 'this.' + expr[1].slice(1).join('.') + '(' +
				expr.slice(2).map(function(e) { return me.compileExpr(e, basepack); }).join(', ') + ')';
		case 'List':
			return '[' + expr.slice(1).map(function(e) { return me.compileExpr(e, basepack); }).join(', ') + ']';
		case 'Times':
			return '(' + expr.slice(1).map(function(e) { return me.compileExpr(e, basepack); }).join(' * ') + ')';
		case 'Plus':
			return '(' + expr.slice(1).map(function(e) { return me.compileExpr(e, basepack); }).join(' + ') + ')';
		case 'Subtract':
			return '(' + expr.slice(1).map(function(e) { return me.compileExpr(e, basepack); }).join(' - ') + ')';
		case 'Divide':
			return '(' + expr.slice(1).map(function(e) { return me.compileExpr(e, basepack); }).join(' / ') + ')';
		case 'Equal':
			return '(' + expr.slice(1).map(function(e) { return me.compileExpr(e, basepack); }).join(' == ') + ')';
		case 'Indexed*':
			if (expr[1][0] !== 'List') throw new Error('Indexed* requires literal list');
			if (expr.length > 3) throw new Error('Indexed* does not yet support multiple args');
			return '(function() {\nswitch (' + me.compileExpr(expr[2], basepack) + ') {\n' +
				expr[1].slice(1).map(function(e,i) { return '  case ' + i + ': return ' + me.compileExpr(e, basepack) + ';\n'}).join('') +
				'}; }).call(this)'
		case 'Indexed': 
			if (expr.length > 3) throw new Error('Indexed does not yet support multiple args');
			var ex = me.compileExpr(expr[1], basepack);
			return '(' + ex + ')[' + me.compileExpr(expr[2], basepack) + ']';
		case 'Index':
			if (expr[1][0] !== 'Symbol') throw new Error('Invalid index parameter ' + clay.code.show(expr));
			expr = expr[1];
			var pack, name;
			if (expr.length > 2) {
				pack = expr[1];
				name = expr[2];
			} else {
				name = expr[1];
				if (me._packages.hasOwnProperty(name))
					pack = name; //for Data tables
				else
					pack = basepack;
			}
			return me.Symbol(pack + '.' + name);
		case 'IndexOf':
			if (expr[1][0] !== 'Symbol') throw new Error('Invalid indexOf parameter ' + clay.code.show(expr));
			var ex = me.compileExpr(expr[2], basepack);
			expr = expr[1];
			var pack, name;
			if (expr.length > 2) {
				pack = expr[1];
				name = expr[2];
			} else {
				name = expr[1];
				if (me._packages.hasOwnProperty(name))
					pack = name; //for Data tables
				else
					pack = basepack;
			}
			return "this['" + pack + "']['" + name +"'].indexOf(" + ex + ")";
		case 'Over':
			return me.compileOver(expr, basepack);
		case 'Symbol':
			var pack, name;
			if (expr.length > 2) {
				pack = expr[1];
				name = expr[2];
			} else {
				name = expr[1];
				if (me._packages.hasOwnProperty(name))
					pack = name; //for Data tables
				else
					pack = basepack;
			}
			//if symbol defined (then annotateDimensions of definition)
			if (me._packages[pack] !== undefined && me._packages[pack].functions[name]) {
				var dims = me._packages[pack].functions[name].dimensions.map(function(d) { return me.Symbol(d); });
				return "this['" + pack + "']['" + name +"'](" + dims.join(', ') + ")";
			} else {
				return '"' + expr.slice(1).join('.') + '"';
			}
		case 'String':
			return '"' + expr[1] + '"';
		case 'Number':
			return expr[1].toString();
		default:
			throw new Error('Compile Error: Not implemented for ' + clay.code.show(expr));
	};
};

Clay.prototype.compileFunc = function(expr, basepack) {
	var me = this;
	switch(expr[0]) {
		case 'Category':
			return indexed(new Function(me.compileExpr(expr, basepack)));
		case 'Func*':
			var dims = expr.dimensions.map(function(d) { return me.Symbol(d); });
			return unmemoize(new Function(dims, me.compileExpr(expr, basepack)));
		case 'Func':
			var dims = expr.dimensions.map(function(d) { return me.Symbol(d); });
			return memoize(new Function(dims, me.compileExpr(expr, basepack)));
		default:
			var dims = expr.dimensions.map(function(d) { return me.Symbol(d); });
			var ov = 'return (' + me.compileExpr(expr, basepack) + ');';
			//console.log(ov);
			try {
				return memoize(new Function(dims, ov));
			} catch (er) {
				console.log('Could not compile: ' + ov);
				console.log(er.message);
				return memoize(new Function('return undefined;'));
			}
			
	};
};

Clay.prototype.recalculate = function() {
	var environment, packages = {}, pack;
	
	environment = new Environment();

	//Namespace is the compiled equivalent of Package
	function Namespace() {};
	Namespace.prototype = environment;

	this.models.forEach(function(model) {
		//add missing packages
		model.packages.forEach(function(p) {
			if (!packages.hasOwnProperty(p)) {
				packages[p] = new Package(p);
			}
		});
		//collect functions
		for (var k in model.functions) {
			var func = model.functions[k];
			var symb = func[1];
			var p = symb[1];
			var name = symb[2];
			pack = packages[p];
			if (pack.functions.hasOwnProperty(name)) {
				func.length = 0;
				func[0] = 'Error';
				func[1] = 'Cannot redefine ' + name;
			} else {
				pack.functions[name] = func;
			}
		};

		var pack = packages[model.package];
		//collect expressions (after so we can get the errors)
		for (var k in model.expressions) {
			pack.expressions[k] = model.expressions[k];
		};
	});

	//find all dimensions (here not in the package as it needs to go over package)
	function findDimensions(expr, basepack) {
		function addDimension(symb, parent) {
			var pack, name;
			if (symb.length > 2) {
				pack = symb[1];
				name = symb[2];
			} else {
				pack = basepack;
				name = symb[1];
			}
			if (packages.hasOwnProperty(name)) pack = name; //for Data tables
			if (!packages[pack].functions.hasOwnProperty(name)) {
				//create dummy function for unsatisfied category
				var sy = ['Symbol', pack, name];
				packages[pack].functions[name] = ['Category', sy, ['List']];
				packages[pack].functions[name].dimensions = [pack + '.' + name];
				packages[pack].unsatisfieds[name] = true;
			}
			packages[pack].dimensions[name] = packages[pack].functions[name];

		}
		//set dimensions on actual categories
		if (expr[0] === 'Category') {
			expr.dimensions = [expr[1][1] + '.' + expr[1][2]];
		}

		clay.code.visit(expr, function(ast, path, index) {
			switch (ast[0]) {
				case 'LetS':
				case 'LetG': {
					var lhs = ast[1];
					if (lhs[0] === 'Symbol')
						addDimension(lhs, ast);
					break;
				}
				case 'Over':
				case 'Indexed': {
					//all symbols are dimensions (Over expr symb..)
					for (var i = ast.length - 1; i >= 2; i--) {
						addDimension(ast[i], ast);	
					}
					break;
				}
				case 'Count': //param must be a dimension
				case 'Index': //param must be a dimension
				case 'IndexOf': //lhs must be a dimension
				case 'Name': //param must be a dimension
					var lhs = ast[1];
					if (lhs !== undefined && lhs[0] === 'Symbol')
						addDimension(lhs, ast);
					break;
			};
		});
	}

	this.models.forEach(function(model) {
		for (var k in model.functions) 
			if (model.functions.hasOwnProperty(k))
				findDimensions(model.functions[k], model.package);
		//definitions should not depend on expressions
		/*for (var k in model.expressions) 
			if (model.expressions.hasOwnProperty(k))
				findDimensions(model.expressions[k], model.package);*/
	});

	function union(l,r) {
		var u = {}, ret = [];
		for (var i = l.length - 1; i >= 0; i--) {
			u[l[i]] = true;
		};
		for (var i = r.length - 1; i >= 0; i--) {
			u[r[i]] = true;
		};
		for (var k in u) {
			if (u.hasOwnProperty(k))
				ret.push(k);
		};
		return ret;
	}

	function equal(l, r) {
		if (l.length !== r.length)
			return false;
		var u = {}, ret = [];
		for (var i = l.length - 1; i >= 0; i--) {
			u[l[i]] = true;
		};
		for (var i = r.length - 1; i >= 0; i--) {
			if (!u.hasOwnProperty(r[i]))
				return false;
		};
		return true;
	}

	function subtract(l, r) {
		var u = {}, ret = [];
		for (var i = l.length - 1; i >= 0; i--) {
			u[l[i]] = true;
		};
		for (var i = r.length - 1; i >= 0; i--) {
			if (u.hasOwnProperty(r[i]))
				delete u[r[i]];
		};
		for (var k in u) {
			if (u.hasOwnProperty(k))
				ret.push(k);
		};
		return ret;
	}

	var hasChanged = true, pass = 0, maxPasses = 10;
	//annotate dimensions of functions
	function annotateDimensions(expr, pass, basepack) {
		if (typeof(expr) === 'string')
			return [];
		if (expr.dimensions !== undefined) {
			if (expr.pass === pass) {
				return expr.dimensions;
			}
		} else {
			expr.dimensions = [];
		}
		expr.pass = pass;
		var ret = [];
		switch(expr[0]) {
			case 'LetS':
				//(LetS symb value expr)
				ret = annotateDimensions(expr[3], pass, basepack);
				var symb = annotateDimensions(expr[1], pass, basepack);
				var value = annotateDimensions(expr[2], pass, basepack);
				if (symb.length > 1)
					throw new Error('Category Error ' + clay.code.show(expr[1]) + ' used as category but has dimensions ' + symb);
				ret = subtract(ret, symb);
				ret = union(ret, value);
				break;
			case 'IndexOf': // dim(IndexOf (Symb ..), value) is dim(value)
				return annotateDimensions(expr[2], pass, basepack);
			case 'Category':
				var x = annotateDimensions(expr[2], pass, basepack);
				if (x.length > 0)
					throw new Error('Categories cannot vary over another category: ' + clay.code.show(expr));
				return expr.dimensions;
			case 'Symbol':
				var pack, name;
				if (expr.length > 2) {
					pack = expr[1];
					name = expr[2];
				} else {
					name = expr[1];
					if (packages.hasOwnProperty(name))
						pack = name; //for Data tables
					else
						pack = basepack;
				}
				//if symbol defined (then annotateDimensions of definition)
				if (packages[pack] !== undefined && packages[pack].functions[name])
					ret = annotateDimensions(packages[pack].functions[name], pass, basepack);
				//else (nothing)
				break;
			case 'Number':
				return expr.dimensions;
			case 'String':
				return expr.dimensions;
			case 'Over':
				var temp = annotateDimensions(expr[1], pass, basepack);
				var u = {}, x;
				for(var i=expr.length - 1; i > 1; i--) {
					if (expr[i] instanceof Array)
						x = annotateDimensions(expr[i],pass, basepack);
						if (x.length > 1) {
							throw new Error('Category Error: ' + clay.code.show(expr[i]) + ' use as category but has multiple dimensions');
						}
						u[x[0]] = true;
				};
				for (var i = temp.length - 1; i >= 0; i--) {
					if (!u.hasOwnProperty(temp[i]))
						ret.push(temp[i]);
				};
				break;
			case 'NoDim': //NoDim has no dimensions
				annotateDimensions(expr[1], pass, basepack);
				ret = [];
				break;
			default:
				for(var i=expr.length - 1; i > 0; i--) {
					if (expr[i] instanceof Array)
						ret = union(ret, annotateDimensions(expr[i],pass, basepack));
				};
		};
		if (!equal(ret,expr.dimensions)) {
			expr.dimensions = ret;
			hasChanged = true;
		};
		return expr.dimensions;
	}

	while (hasChanged && pass < maxPasses) {
		hasChanged = false;
		this.models.forEach(function(model) {
			for (var k in model.functions) 
				if (model.functions.hasOwnProperty(k))
					annotateDimensions(model.functions[k],pass, model.package);
			for (var k in model.expressions) 
				if (model.expressions.hasOwnProperty(k))
					annotateDimensions(model.expressions[k],pass, model.package);
		});
		pass = pass + 1;
	}
	if (pass === maxPasses) {
		throw new Error('Dimensions Error: Could not infer dimensions');
	}

	this._environment = environment;
	this._packages = packages;

	//compile functions
	for (pack in packages) {
		if (packages.hasOwnProperty(pack)) {
			var packg = packages[pack];
			environment[pack] = new Namespace();
			for (var name in packg.functions) {
				if (packg.functions.hasOwnProperty(name)) {
					var func = packg.functions[name];
					environment[pack][name] = this.compileFunc(func, pack)
				}
			}
		}
	}

	//TODO: Fixup expressions with non empty dimensions..
	// turn them into basic tables...

	//compile expressions (and bind to namespace)
	for (pack in packages) {
		if (packages.hasOwnProperty(pack)) {
			var env = environment[pack];
			var packg = packages[pack];
			for (var name in packg.expressions) {
				if (packg.expressions.hasOwnProperty(name)) {
					var expr = packg.expressions[name];
					expr.compiled = this.compileFunc(expr, pack).bind(env);
				}
			}
		}
	}

	//TODO: add custom functions to namespace they were defined in


};

Clay.prototype.addModel = function(model) {
	if (this.models.length === 1 && this.models[0] === Blank && !Blank.isModified()) {
		this.models = [];
		this._models = {};
	}
	this.models.push(model);
	this._models[model.name] = model;
	this.recalculate();
};

Clay.prototype.close = function(name) {
	var m = this._models[name];
	delete this._models[name];
	var i = this.models.length;
	while (i--)
		if (this.models[i] === m) 
			break;
	if (i >= 0)
		this.names.splice(i, 1);
	this.recalculate();
};

Clay.prototype.charOffset = function(name, path, toff) {
	return this.model(name).charOffset(path, toff);
};

Clay.prototype.openModel = function(name, callback) {
	if (this._models[name] !== undefined) {
		if (callback) callback(name); //file already open just switch to it
	} else {
		fetchFile('models/'+name + '.model', function(data) {
			if (data !== undefined) {
				this.addModel(new Model(name, data));
				if (callback) callback(name);
			}
		}.bind(this));
	}
};

Clay.prototype.revert = function(name, callback) {
	this.model(name).revert();
	this.recalculate();
	if (callback) callback(name);
};

Clay.prototype.update = function(name, source) {
	this.model(name).update(source);
	this.recalculate();
};

Clay.prototype.name = function(name) {
	var i = this.names.length;
	while (i--)
		if (this.names[i].name == name)
			return this.names[i];
	return {}
};

var MenuToggle = React.createClass({
	render: function() {
		return a({href:"#menu", id:"menuLink", className:"menu-link"}, span(null));
	},
});

var MenuItem = React.createClass({
	clicked: function(event) {
		this.props.clicked(this.props.item.name);
	},
	render: function() {
		var item = this.props.item,
			classes = React.addons.classSet({
			'menu-item-divided': this.props.divided,
			'pure-menu-selected': this.props.selected,
			'menu-modified': item.isModified && item.isModified(),
		});
		return li({onClick: this.clicked, className: classes},
			a({href:"#" + item.name}, item.name))
	},
});

var Menu = React.createClass({
	renderItem: function(item,idx) {
		return MenuItem({item:item, 
			key: idx,
			divided: item.separator, 
			selected: (item.name == this.props.selected), 
			clicked: item.func});
	},
	renderFile: function(item, idx) {
		return MenuItem({item:item, 
			divided: (idx == 0),
			key: idx,
			selected: (item.name == this.props.selected), 
			clicked: this.props.fileClick});
	},
	render: function() {

		return div({id:"menu"},
			div({className:"pure-menu pure-menu-open"},
				a({className:"pure-menu-heading", href:"#"},title),
				ul(null,this.props.items.map(this.renderItem),
					this.props.files.map(this.renderFile))));
	},
});

var FileItem = React.createClass({
	clicked: function(event) {
		this.props.clicked(this.props.path + this.props.item.name.replace(/\.model$/,''));
	},
	render: function() {
		var item = this.props.item.name,
			name = this.props.path + item.replace(/\.model$/,'');
		return li({onClick: this.clicked},
			a({href:"#" + name}, name))
	},
});

var DirectoryItem = React.createClass({
	renderItem: function(item, idx) {
		if (item.type === 'directory') {
			return DirectoryItem({clicked: this.props.clicked,
				key: idx,
				directory: item,
				path: this.props.path + item.name + '/'});
		}
		return FileItem({clicked: this.props.clicked, key: idx, item: item, path: this.props.path});
	},
	render: function() {
		return ul({className: 'models'}, this.props.directory.children.map(this.renderItem));
	},
});

var FileList = React.createClass({
	getInitialState: function() {
		return {data: []};
	},
	componentWillMount: function() {
		$.ajax({
			url: 'models.json',
			dataType: 'json',
			success: function(data) {
				this.setState({data: data});
			}.bind(this),
			error: function(xhr, status, err) {
				console.error('models.json', status, err.toString());
			}.bind(this)
		});
	},
	render: function() {
		return div(null,
			div({className: 'header'}, h1(null, "Open Model"), h2(null, "Choose a model to open")),
			DirectoryItem({directory:{children: this.state.data}, path:'', clicked: this.props.clicked}));
	},
});

var Selection = React.createClass({
	getInitialState: function() {
		return {
			selection: null,
		}
	},
	componentDidUpdate: function() {
		/*var rects, rect;
		if (this.state.selection !== null &&
			(rects = this.state.selection.getClientRects()).length > 0) {
			rect = rects[0];
			window.scrollTo(rect.left, rect.top);
		}*/
	},
	renderSelection: function(range) {
		var rects = range.getClientRects(),
			r = range.getBoundingClientRect()
		  , ret = []
		  , cs
		  , fbot
		  , rect
		  , farLeft = Math.floor(r.left)
		  , farRight = Math.ceil(r.right)
		  , scrollTop = document.documentElement.scrollTop || document.body.scrollTop
          , scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft
          , len = rects.length
          , i;
        if (len > 0) {
        	rect = rects[0];
        	cs = {
        		top: (rect.top + scrollTop) + 'px',
        		left: (rect.left + scrollLeft) + 'px',
        		height: rect.height + 'px',
        		width: (farRight - rect.left) + 'px',
        	}
			fbot = rect.bottom;
        	ret.push(div({style:cs, key:'first'}," "));
        }
        if (len > 1) {
        	rect = rects[len - 1];
        	cs = {
        		left: (farLeft + scrollLeft) + 'px',
        		width: (rect.right - farLeft) + 'px',
        	}
			var gap = rect.top - fbot;
			if (gap < rect.height * 0.6) {
				cs.top = (rect.top + scrollTop - gap) + 'px';
        		cs.height = (rect.height + gap) + 'px';
			} else {
        		cs.top = (rect.top + scrollTop) + 'px';
        		cs.height = rect.height + 'px';
        		// now draw the gap
        		ret.push(div({style: {
        			top: (fbot + scrollTop) + 'px',
        			left: (farLeft + scrollLeft) + 'px',
        			width: (farRight - farLeft) + 'px',
        			height: gap + 'px'
        		}, key: 'mid'}, " "));
			}
			ret.push(div({style: cs, key: 'last'}, " "));
        }
        return ret;
	},
	render: function() {
		var range = this.state.selection; //selection range
		if (range === null)
			return div(null);

		var rects = range.getClientRects(),
			scrollTop = document.documentElement.scrollTop || document.body.scrollTop,
        	scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;
        if (rects.length === 0)
        	return div(null);

		if (range.collapsed) {
			var rect = rects[0],
				cs = {
					top: (rect.top + scrollTop) + 'px',
					left: (rect.right + scrollLeft - 1) + 'px',
					height: rect.height + 'px',
					display: 'block',
				};
			return div(null,span({className: "cursor", style: cs}, " "));
		} else {
			return div({className: "selection"},
				this.renderSelection(range));
		}
	},
});

var Result = React.createClass({
	componentDidMount: function() {
		if (isElement(this.props.value)) { // instanceof Array && this.props.value[0] === 'element') {
			var el = this.getDOMNode(), last;
			while (last = el.lastChild) el.removeChild(last);
			el.appendChild(this.props.value);
		}
	},
	componentDidUpdate: function() {
	},
	render: function() {
		if (this.props.inline)
			return span({className: 'result'}, (this.props.value !== undefined) ? this.props.value.toString() : "NULL");
		else
			return div({className: 'result'}, (this.props.value !== undefined) ? this.props.value.toString() : "NULL");
	},
});

var Renderer = React.createClass({
	rangeFor: function(start, end) {
		var rootId = this._rootNodeID + '.',
			range = document.createRange(),
			ast = this.props.model.model(this.props.name).ast.children;
		function setEnd(items, pos, isStart) {
			var item,
			i,l,path = [];
			while(items !== undefined) {
				l = items.length;
				for(i = 0; i < l; i++) {
					item = items[i];
					if (item.pos > pos) {
						break;
					}
				}
				item = items[--i];
				path.push('$' + i);
				switch(item.type) {
					case 'code':
						//path.push('$_'); //pre
						path.push('$_'); //code
						break;
					//case 'codespan':
					//	path.push('$_'); //code
					//	break;
					case 'table':
						if (pos < item.cells.pos) {
							path.push('$head');
							if (pos < item.align.pos) {
								path.push('$0');
								item = item.header;
							} else {
								path.push('$align');
								var tw = item.align.pos,w;
								for (i = 0; i < item.alignText.length; i++) {
									w = item.alignText[i].length + 1;
									if (pos < w + tw) {
										path.push('$' + i);
										item = {pos: tw};
										break;
									}
									tw += w;
								}
							}
						}
						else {
							path.push('$body');
							item = item.cells;
						}
						break;
				}
				if (item.hasOwnProperty('children')) {
					items = item.children;
				} else if ($.isArray(item)) {
					//items are a
					items = item;
				} else {
					items = undefined;
					pos -= item.pos;
				}
			}
			var x = $('[data-reactid="'+ rootId + path.join('.')+'"]')[0];
			if (x !== undefined)
				if (isStart)
					if (pos > x.firstChild.length) {
						range.setStartAfter(x.firstChild);
					}
					else {
						range.setStart(x.firstChild, pos);
					}
				else
					if (pos > x.firstChild.length) {
						range.setEndAfter(x.firstChild);
					}
					else {
						range.setEnd(x.firstChild, pos);
					}
		}
		setEnd(ast, start, true);
		if (start === end)
			range.setEnd(range.startContainer, range.startOffset);
		else
			setEnd(ast, end, false);
		return range;
	},
	handleMouseUp: function(e) {
		var x = this.props.selectionChanged;
		if (x) {
			//calculate the selection from the data-ids
			var selected = window.getSelection();
			if (selected.rangeCount < 1)
				return;
			var range = selected.getRangeAt(0),
				startE = range.startContainer.parentElement || range.startContainer.parentNode,
				endE = range.endContainer.parentElement || range.endContainer.parentNode,
				startPath = startE.getAttribute('data-reactid'),
				endPath = endE.getAttribute('data-reactid'),
				rootId = this._rootNodeID + '.';
			if (startPath !== undefined 
				&& endPath !== undefined
				&& startPath.startsWith(rootId)
				&& endPath.startsWith(rootId)) {
				var model = this.props.model, name = this.props.name;
				startPath = startPath.slice(rootId.length).replace(/\$?/g,'').split('.');
				endPath = endPath.slice(rootId.length).replace(/\$?/g,'').split('.');
				var start = model.charOffset(name,startPath, range.startOffset);
				var end = model.charOffset(name,endPath, range.endOffset);
				x(start, end);
			}
		}
	},
	renderHeading: function(item, idx) {
		var id = this.props.name + '-' + item.id,
			content = item.children.map(this.renderTree),
			attr = {id: id, key: idx};
		switch(item.depth) {
			case 1: return h1(attr, content);
			case 2: return h2(attr, content);
			case 3: return DOM.h3(attr, content);
			case 4: return DOM.h4(attr, content);
			case 5: return DOM.h5(attr, content);
			case 6: return DOM.h6(attr, content);
		}
		return h1(attr, content);
	},
	renderCode: function(item, idx) {
		return DOM.pre({key: idx}, DOM.code({key: '_'}, item.children.map(this.renderTree)));
	},
	renderTable: function(item, idx) {
		var align = item.align, rtree = this.renderTree;
		function renderCell(f) {
			return function(c, idx) {
				var a = align[idx], ctx = {key:idx};
				if (a !== null) {
					ctx['style'] = {'text-align': a};
				}
				return f(ctx, c.map(rtree)); 
			}
		}
		function renderTR(r, idx) {
			return DOM.tr({key: idx}, r.map(renderCell(DOM.td)));
		}
		function renderAlign(c, idx) {
			var a = align[idx], ctx = {key:idx};
				if (a !== null) {
					ctx['style'] = {'text-align': a};
			}
			return DOM.td(ctx, c);
		}
		return DOM.table({key: idx, className: 'pure-table pure-table-horizontal'},
			DOM.thead({key:'head'},
				DOM.tr({key: 0}, item.header.map(renderCell(DOM.th))),
				DOM.tr({key: 'align', className: 'align'}, item.alignText.map(renderAlign))),
			DOM.tbody({key:'body'},item.cells.map(renderTR))//,
			//DOM.tfoot({key:'foot'})
			);
	},
	renderResult: function(item, idx) {
		var inline = false,
			expressions = item.code.sexpr,
			models = this.props.model,
			model = models.model(this.props.name),
			p = model.package;

			if (item.code.type === 'codespan') {
				inline = true;
				//expressions = [expressions];
			}
			
			var results = expressions;
			var rresults = clay.code.expressions(expressions)
				.map(function(e,i) { return models.evaluate(p, e); })
				.filter(function(r) { return r !== null; });

			return rresults.map(function(r, i) { return Result({key: idx + '_' + i, value: r, inline: inline}); });

	},
	renderTree: function(item, idx) {
		switch(item.type) {
			case 'text': return span({key: idx},item.text);
			case 'escape': return span({key: idx, dangerouslySetInnerHTML:{__html: item.text}});
			case 'span': return span({key: idx}, item.children.map(this.renderTree));
			case 'meta': return span({key: idx, className: 'meta'}, item.text);
			case 'before': return span({className: 'before', key:idx}, 
				item.text.replace(/ /g,'\u2423').replace(/\t/,'\u2192')); // + (item.newline ? '\n' : '')
			case 'after': 
				var text = item.text.replace(/ /g,'\u2423').replace(/\n/g,'\u00AC');
				if (text.length === 0)
					text = ' '
				return span({className: 'after', key:idx},  text);
			case 'p': return p({key: idx}, item.children.map(this.renderTree));
			case 'em': return DOM.em({key: idx}, item.children.map(this.renderTree));
			case 'strong': return DOM.strong({key: idx}, item.children.map(this.renderTree));
			case 'del': return DOM.del({key: idx}, item.children.map(this.renderTree));
			case 'a': return DOM.a({key: idx, href: item.href, title: item.title}, item.children.map(this.renderTree));
			case 'section': return DOM.section({key: idx}, item.children.map(this.renderTree));
			case 'heading': return this.renderHeading(item, idx);
			case 'table': return this.renderTable(item, idx);
			case 'blockquote': return DOM.blockquote({key: idx}, item.children.map(this.renderTree));
			case 'ul': return ul({key: idx}, item.children.map(this.renderTree));
			case 'ol': return DOM.ol({key: idx}, item.children.map(this.renderTree));
			case 'li': return li({key: idx}, item.children.map(this.renderTree));
			case 'hr': return DOM.hr({key: idx}); //TODO
			case 'br': return DOM.br({key: idx}); //TODO
			case 'code': return this.renderCode(item, idx);
			case 'codespan': return DOM.code({key: idx}, item.text);
			case 'error': 
				var children = item.children.map(this.renderTree);
				children.push(span({className: 'error'}, item.text));
				return div({key: idx}, children);
			case 'html': return div({key: idx,
				dangerouslySetInnerHTML:{__html: item.raw}
				});
			case 'result': return this.renderResult(item, idx);
			default: return p({key: idx},'unsupported: ' + item.type);
		};
	},
	render: function() {
		var model = this.props.model.model(this.props.name);
		if (model === undefined)
			ast = {type:'root', children: []};
		else
			ast = model.ast;
		return div({id: 'preview', 
			ref: 'preview',
			onMouseUp: this.handleMouseUp,
			className: 'editor', 
      		}, ast.children.map(this.renderTree)
      		); 
	},
});

var Editor = React.createClass({
	getInitialState: function() {
		return {
			//TODO this should be an empty model
			currentSource: 'Test of this',
			selected: 'Blank',
			modal: null,
		}
	},
	handleChange: function(e) {
		var source = this.refs.textarea.getDOMNode().value;
		this.setState({currentSource: source});
		this.props.model.update(this.state.selected, source);
	},
	save: function() { console.log('save'); },
	saveAll: function() { console.log('saveAll'); },
	open: function() {
		this.setState({modal: this.openModal});
	},
	close: function() { 
		this.props.model.close(this.state.selected);
		this.switchFile(this.props.model.names[0].name);
	},
	revert: function() {
		this.props.model.revert(this.state.selected, this.switchFile);
	},
	openFile: function(path) {
		this.props.model.openModel(path, this.switchFile);
	},
	newFile: function() {
		this.setState({modal: this.newModal});
	},
	preview: function() {
		return 
	},
	openModal: function() {
		return FileList({clicked: this.openFile});
	},
	newModal: function() {
		return div(null, p(null, 'TODO: put form here with a box for model name'));
	},
	switchFile: function(name) { 
		console.log('switchFile: ' + name);
		var source = this.props.model.model(name).source,
		    ta = this.refs.textarea.getDOMNode();
		this.setState({ selected: name,
			currentSource: source,
			modal: null});
		ta.value = source; //React doesn't set the value of the text area
		ta.setSelectionRange(0,0);
	},
	componentDidMount: function() {
		this.openFile('Example'); //TODO pass in as initial model
	},
	componentDidUpdate: function(prevProps, prevState) {
		this.updateCursor();
	},
	menu: function() {
		// must be wrapped in a function to see the other functions
		// i.e. this.openFile
		// could be done on ComponentWillMount to save a call every time
		return [
			{name: "Open", func: this.open},
			{name: "Close", func: this.close},
			{name: "Revert", func: this.revert},
			{name: "Save", func: this.save, separator: true},
			{name: "Save All", func: this.saveAll},
			{name: "New", func: this.newFile, separator: true},
			];
	},
	updateCursor: function() {
		//TODO might want this to ignore the 
		var ta = this.refs.textarea.getDOMNode(),
		    range = this.refs.preview.rangeFor(ta.selectionStart, ta.selectionEnd);
		this.refs.selection.setState({selection: range});
	},
	handleKeyDown: function(e) {
		if (e.keyCode === 9 && !e.altKey && !e.ctrlKey && !e.shiftKey) { //tab
			var ta = this.refs.textarea.getDOMNode(),
				val = ta.value,
				start = ta.selectionStart,
				end = ta.selectionEnd;
			ta.value = val.substring(0,start) + '\t' + val.substring(end);
			ta.selectionStart = ta.selectionEnd = start + 1;
			this.setState({currentSource: ta.value});
			//manually trigger update
			this.props.model.update(this.state.selected, ta.value);
			return false;
		} else if (e.keyCode === 13 && !e.altKey && !e.ctrlKey && !e.shiftKey) { //return
			var ta = this.refs.textarea.getDOMNode(),
				val = ta.value,
				start = ta.selectionStart,
				end = ta.selectionEnd,
				lineStart = val.lastIndexOf('\n',start-1) + 1;
			if (start === end && /^\n\t(\n|$)/.test(val.slice(start-2,start+1))) {
				ta.value = val.substring(0,start-1) + '\n' + val.substring(end);
				ta.selectionStart = ta.selectionEnd = start;
				this.setState({currentSource: ta.value});
				//manually trigger update
				this.props.model.update(this.state.selected, ta.value);
				return false;
			} else if (val.slice(lineStart,lineStart+1) === '\t' || val.slice(lineStart,lineStart + 4) === '    ') {
				ta.value = val.substring(0,start) + '\n\t' + val.substring(end);
				ta.selectionStart = ta.selectionEnd = start + 2;
				this.setState({currentSource: ta.value});
				//manually trigger update
				this.props.model.update(this.state.selected, ta.value);
				return false;
			}
		}
		return true;
	},
	//Note: these are getting called every click...
	handleBlur: function() {
		this.refs.selection.setState({selection: null});
	},
	handleFocus: function() {
		//textarea gained focus (draw selection)
		this.updateCursor();
	},
	handleKeyUp: function() {
		this.updateCursor();
	},
	handleSelect: function(start, end) {
		var ta = this.refs.textarea.getDOMNode();
		ta.setSelectionRange(start, end); //do this before and after focus so update cursor works
		ta.focus();
		ta.setSelectionRange(start, end); //TODO: remove (just here to scroll the text area)
		this.updateCursor();
	},
	render: function() {
		return div({className: (this.state.modal !== null ? "modal" : "view")},
			DOM.textarea({id: 'model', 
						onChange: this.handleChange,
						onKeyDown: this.handleKeyDown,
						onKeyUp: this.handleKeyUp,
						onFocus: this.handleFocus,
						onBlur: this.handleBlur,
						ref: "textarea", 
						style: {opacity: '0', position: 'fixed', width: '100%', 'max-width': '800px'},
						value: this.state.value}),
			div({id:'layout'},
				MenuToggle(null),
				Menu({items: this.menu(), files:this.props.model.models, 
					selected:this.state.selected, fileClick: this.switchFile}),
				div({id:'main'},
					div({className:'content'},
						Selection({ref: 'selection'}),
						(this.state.modal === null ? null : this.state.modal()), //Dialog box
						Renderer({model:this.props.model, 
							ref: 'preview',
							name:this.state.selected,
							selectionChanged: this.handleSelect,
							})
						))));
	},
});


var models = new Clay();
var ed = Editor({model: models});
React.renderComponent(ed, document.body);
//ed.openFile('Example');


</script>
<script src="js/ui.js"></script>
</body>
</html>