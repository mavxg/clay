<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<title>Test</title>
	<link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,700|Inconsolata" />
<link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.5.0/pure-min.css"/>
<!--[if lte IE 8]>
    <link rel="stylesheet" href="css/layouts/side-menu-old-ie.css">
<![endif]-->
<!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="css/layouts/side-menu.css">
<!--<![endif]-->
<link rel="stylesheet" href="/css/clay.css"/>

	<style type="text/css" media="screen">
	code {
	  white-space: pre;
	}

*:focus {
				outline: none;
}

.token.keyword {
				color: #66D9EF;
}

p.meta {
				margin: 0;
				color: rgb(202, 224, 243);
}

div.options {
		background-color: #262625;
		border-radius: 5px;
		z-index: 100;
		padding: 5px 4px 5px 5px;
		transition: all 300ms ease-in-out;
		height: 33px;
		width: 270px;
		font-family: Georgia, serif;
}

.options .italic {
		font-style: italic;
}

.options button {
float: left; /* to hide the input */
width: 28px;
height: 30px;
border-radius: 3px;
margin-right: 1px;
}

.options input {
border-radius: 3px;
overflow: hidden;
outline: 0px;
height: 30px;
padding: 0px;
margin: 0px;
border: 0px;
float: left;
width: 0px;
}

.text-menu {
-webkit-transition: opacity 180ms, margin 180ms;
-ms-transition: opacity 180ms, margin 180ms;
transition: opacity 180ms, margin 180ms;
color: #fff;
position: fixed;
		top: 10px;
		left: 50%;

}


.text-menu button {
-webkit-transition: opacity 400ms;
-ms-transition: opacity 400ms;
transition: opacity 400ms;
font-family: inherit;
background: none;
cursor: pointer;
font-size: 16px;
color: inherit;
padding: 0px;
height: 32px;
width: 25px;
border: 0px;
outline: none;
-webkit-touch-callout: none;
-webkit-user-select: none;
-khtml-user-select: none;
-moz-user-select: none;
-ms-user-select: none;
user-select: none;
}

.options button {
float: left;
width: 28px;
height: 30px;
border-radius: 3px;
margin-right: 1px;
}


.options:before {
content: "";
border-top: 5px solid rgba(0,0,0,0.9);
border-bottom: 5px solid transparent;
border-right: 5px solid transparent;
border-left: 5px solid transparent;
position: absolute;
margin-left: -5px;
bottom: -15px;
height: 5px;
width: 0px;
left: 50%;
}
	/*
	code::after {
		content: "⏎";
	}*/

#preview > code {
margin: 1.6em 0;
box-sizing: border-box;
background: rgb(250, 250, 250);
border: 1px solid #eee;
padding: 10px;
font-size: 0.9em;
/*white-space: pre;*/
/*border-radius: 3px;*/
display: block;
}
	</style>

</head>
<body id="" onload="">
<div class="text-menu active">
<div class='options'>
          <span class='no-overflow'>
            <span class='ui-inputs'>
              <button class='bold'>B</button>
              <button class='italic'>i</button>
              <button class='header1'>h1</button>
              <button class='header2'>h2</button>
              <button class='header3'>h3</button>
              <button class='header4'>h4</button>
              <button class='quote'>&rdquo;</button>
              <button class='code'>&rang;</button>
              <button class='url useicons'>&#xe001;</button>
              <input class='url-input' type='text' placeholder='Paste or type a link'/>
            </span>
          </span>
        </div>
</div>
</div>
<div id="layout">
    <!-- Menu toggle -->

    <div id="main">
<div class="content">

	<div id="preview" contentEditable="true" >
		<h1 id="first_file">First File</h1>
		<p>Some first file text</p>
		<code>Some <span class="token keyword">code</span>.

</code>
		<p>Some text with <code>inline code</code> and some other stuff after</p>
		<p>Some text with <code>inline code at the end</code></p>

		<div contentEditable="true" readonly="readonly">This is not editable in everything except IE8-11 where you need to set it to contentEditable="true"</div>
<table class="pure-table pure-table-horizontal">
<thead>
<tr>
<th><span>Data.State[]</span></th>
<th><span>.Gender[]</span></th>
<th><span>.City[]</span></th>
<th><span>.Pop[]</span></th>
</tr>
</thead>
<tbody>
<tr>
<td><span>WA</span></td>
<td><span>M</span></td>
<td><span>Seattle</span></td>
<td><span>2</span></td>
</tr>
<tr>
<td><span>WA</span></td>
<td><span>F</span></td>
<td><span>Seattle</span></td>
<td><span>23</span></td>
</tr>
<tr>
<td><span>KS</span></td>
<td><span>M</span></td>
<td><span>Lawrence</span></td>
<td><span>4</span></td>
</tr>
<tr>
<td><span>KS</span></td>
<td><span>F</span></td>
<td><span>Lawrence</span></td>
<td><span>345</span></td>
</tr>
<tr>
<td><span>FL</span></td>
<td><span>M</span></td>
<td><span>Miami</span></td>
<td><span>546</span></td>
</tr>
<tr>
<td><span>FL</span></td>
<td><span>F</span></td>
<td><span>Miami</span></td>
<td><span>2</span></td>
</tr>
<tr>
<td><span>FL</span></td>
<td><span>M</span></td>
<td><span>Orlando</span></td>
<td><span>1000</span></td>
</tr>
<tr>
<td><span>FL</span></td>
<td><span>F</span></td>
<td><span>Orlando</span></td>
<td><span>2000</span></td>
</tr>
</tbody>
</table>

	</div>


<div class="result">
<div class='pure-g'>
<h3 class='pure-u-2-5' style='margin-top: 20px;'>Net Income</h3>
<form class="pure-form pure-u-3-5" style='text-align: right;'>
    <fieldset>
    	<label for="state">State = </label>
        <select id="state">
            <option>AL</option>
            <option>CA</option>
            <option>IL</option>
        </select>
        <label for="statey">Gender = </label>
        <select id="statey">
            <option>M</option>
            <option>F</option>
        </select>
    </fieldset>
</form>
</div>
<table class="pure-table pure-table-horizontal">
<thead>
<tr>
<th class='empty highlight'></th>
<th class='empty highlight'></th>
<th><span>Hufflepuff</span></th>
<th></th>
<th></th>
<th></th>
<th><span>Griffindor</span></th>
<th></th>
<th></th>
<th></th>
<th><span>Slitherin</span></th>
<th></th>
</tr>
<tr>
<th class='empty highlight'></th>
<th class='empty highlight'></th>
<th>Data.State[]</th>
<th><span>.Gender[]</span></th>
<th><span>.City[]</span></th>
<th><span>.Pop[]</span></th>
<th><span>.Pop[]</span></th>
<th><span>.Pop[]</span></th>
<th><span>.Pop[]</span></th>
<th><span>.Pop[]</span></th>
<th><span>.Pop[]</span></th>
<th><span>.Pop[]</span></th>
</tr>
<tr>
<th class='highlight'>State</th>
<th class='highlight'>Gender</th>
<th><span>Data.State[]</span></th>
<th><span>.Gender[]</span></th>
<th><span>.City[]</span></th>
<th><span>.Pop[]</span></th>
<th><span>.Pop[]</span></th>
<th><span>.Pop[]</span></th>
<th><span>.Pop[]</span></th>
<th><span>.Pop[]</span></th>
<th><span>.Pop[]</span></th>
<th><span>.Pop[]</span></th>
</tr>
</thead>
<tbody>
<tr>
<td class='highlight'><span>WA</span></td>
<td class='highlight'><span>M</span></td>
<td><span>Seattle</span></td>
<td><span>2</span></td>
<td><span>WA</span></td>
<td><span>M</span></td>
<td><span>Seattle</span></td>
<td><span>2</span></td>
<td><span>WA</span></td>
<td><span>M</span></td>
<td><span>Seattle</span></td>
<td><span>2</span></td>
</tr>
<tr>
<td class='highlight'><span>WA</span></td>
<td class='highlight'><span>F</span></td>
<td><span>Seattle</span></td>
<td><span>23</span></td>
<td><span>WA</span></td>
<td><span>M</span></td>
<td><span>Seattle</span></td>
<td><span>2</span></td>
<td><span>WA</span></td>
<td><span>M</span></td>
<td><span>Seattle</span></td>
<td><span>2</span></td>
</tr>
<tr>
<td class='highlight'><span>KS</span></td>
<td class='highlight'><span>M</span></td>
<td><span>Lawrence</span></td>
<td><span>4</span></td>
<td><span>WA</span></td>
<td><span>M</span></td>
<td><span>Seattle</span></td>
<td><span>2</span></td>
<td><span>WA</span></td>
<td><span>M</span></td>
<td><span>Seattle</span></td>
<td><span>2</span></td>
</tr>
<tr>
<td class='highlight'><span>KS</span></td>
<td class='highlight'><span>F</span></td>
<td><span>Lawrence</span></td>
<td><span>345</span></td>
<td><span>WA</span></td>
<td><span>M</span></td>
<td><span>Seattle</span></td>
<td><span>2</span></td>
<td><span>WA</span></td>
<td><span>M</span></td>
<td><span>Seattle</span></td>
<td><span>2</span></td>
</tr>
<tr>
<td class='highlight'><span>FL</span></td>
<td class='highlight'><span>M</span></td>
<td><span>Miami</span></td>
<td><span>546</span></td>
<td><span>WA</span></td>
<td><span>M</span></td>
<td><span>Seattle</span></td>
<td><span>2</span></td>
<td><span>WA</span></td>
<td><span>M</span></td>
<td><span>Seattle</span></td>
<td><span>2</span></td>
</tr>
<tr>
<td class='highlight'><span>FL</span></td>
<td class='highlight'><span>F</span></td>
<td><span>Miami</span></td>
<td><span>2</span></td>
<td><span>WA</span></td>
<td><span>M</span></td>
<td><span>Seattle</span></td>
<td><span>2</span></td>
<td><span>WA</span></td>
<td><span>M</span></td>
<td><span>Seattle</span></td>
<td><span>2</span></td>
</tr>
<tr>
<td class='highlight'><span>FL</span></td>
<td class='highlight'><span>M</span></td>
<td><span>Orlando</span></td>
<td><span>1000</span></td>
<td><span>WA</span></td>
<td><span>M</span></td>
<td><span>Seattle</span></td>
<td><span>2</span></td>
<td><span>WA</span></td>
<td><span>M</span></td>
<td><span>Seattle</span></td>
<td><span>2</span></td>
</tr>
<tr>
<td class='highlight'><span>FL</span></td>
<td class='highlight'><span>F</span></td>
<td><span>Orlando</span></td>
<td><span>2000</span></td>
<td><span>WA</span></td>
<td><span>M</span></td>
<td><span>Seattle</span></td>
<td><span>2</span></td>
<td><span>WA</span></td>
<td><span>M</span></td>
<td><span>Seattle</span></td>
<td><span>2</span></td>
</tr>
</tbody>
</table>
</div>

</div>
</div>
</div>
<script type="text/javascript">
var editor, meta;
editor = document.getElementById('preview');

var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;

if (isFirefox) {
	var getTextProp = function(node) { 
		return (node.nodeType === Node.TEXT_NODE) ? 'data' : 'textContent'; 
	};
} else {
	var getTextProp = function(node) { 
		return (node.nodeType === Node.TEXT_NODE) ? 'data' : 'innerText';
	};
}

function handleKeyup(event) {
	if (event.keyCode === 13) {
		var sel = document.getSelection();
		if (sel.anchor && sel.anchor.nodeName === "DIV") {
			document.execCommand("formatBlock", false, "p");
		}
	}
}

//TODO fix for IEs
var insertHtml = function(text) {
	return document.execCommand('insertHtml',false,text);
};

var getParentWithTag = function(node, tag) {
	while (node) {
		if (node.nodeName === tag) return node;
		node = node.parentNode;
	}
};

function handleKeydown(event) {
	if (event.keyCode === 13) { //todo need to check for shift character
		var sel = document.getSelection()
		  , range
			, currentNodes = findNodes(sel.focusNode, editor);
		if (!!currentNodes['CODE']) {
			if (sel.rangeCount) {
				range = sel.getRangeAt(0);
				//TODO this doesn't work if we are in a span in code (walk up the last nodes)
				var atEnd = (range.endContainer.parentNode.lastChild === range.endContainer) &&
											(range.endContainer.length <= range.endOffset + 1); // && !!currentNodes['PRE'];
				//also need to do atEnd and currentNodes['P']
				if (atEnd) {
					if ((range.collapsed || sel.isCollapsed)
													&& sel.anchorNode.textContent[sel.anchorOffset-1] === '\n') {
						document.execCommand('delete')
						var pre = getParentWithTag(range.endContainer, 'CODE'); // 'PRE');
						range.setStartAfter(pre);
						range.setEndAfter(pre); //collapse(true);
						sel.removeAllRanges();
						sel.addRange(range);
						document.execCommand('insertParagraph');
						sel.removeAllRanges();
						sel.addRange(range);
					} else {
						var ec = range.endContainer;
						if (range.endContainer.length === range.endOffset) {
										insertHtml("\n\n"); //because the last newline gets gobbled
						} else {
										insertHtml("\n");
						}
						range.setStart(ec, ec.length-1);
						range.setEnd(ec, ec.length-1);
					  sel.removeAllRanges();
						sel.addRange(range);
					}
				} else {
					insertHtml("\n");
				}
				event.preventDefault();
			}
		}
	} // enterKey

/*

				var nl;
								if (range.collapsed) {
					if  (range.endContainer.parentNode.lastChild
					=== range.endContainer &&
					range.endContainer.textContent == '\n\n') {
						range.endContainer.parentNode.removeChild(range.endContainer);
						var pre = range.endContainer.parentNode; //TODO this is flaky
						range.setStartAfter(pre);
						range.setEndAfter(pre);
						selection.removeAllRanges();
						selection.addRange(range);
						document.execCommand('insertParagraph',false);
						event.preventDefault();
					}
				} else {
					range.deleteContents();
				}
				if (range.endContainer.parentNode.lastChild
					=== range.endContainer
					&& range.endContainer.length
					=== range.endOffset) {
						//TODO this should use execCommand('insertText',false, "\n\n");
						// except on IE where this doesn't work (you could do a shim for IE)
						//that does what the below does
						nl = document.createTextNode("\n\n"); //put an extra newline at the end
						range.setStartAfter(range.endContainer);
					} else {
						nl = document.createTextNode("\n");
					}
				range.insertNode(nl);
				range = document.createRange();
				range.setStart(nl, 1);
				range.setEnd(nl, 1);
				selection.removeAllRanges();
				selection.addRange(range);
				event.preventDefault();
			}
		}
	}
	*/
}

function findNodes(node, root) {
	var nodes = {};
	while (node !== root) {
		nodes[node.nodeName] = true;
		if (node.nodeName === "A") nodes.url = node.href;
		node = node.parentNode;
		if (node === undefined) return {}; //not child of root
	}
	return nodes;
}

editor.onkeyup = handleKeyup;
editor.onkeydown = handleKeydown;


function Namespace(name) {
	//this.name = name; //Don't -- this introduces a keyword name.
	Namespace.prototype[this.name] = this;
}

Namespace.get = function(name) {
	return Namespace.prototype[name];
};

Namespace.getOrCreate = function(name) {
	if (Namespace.prototype[name] === undefined)
		return new Namespace(name);
	return Namespace.prototype[name];
};

var camelCase = function(name) {
	return (name
		.toLowerCase()
		.replace(/[^a-zA-Z]+([a-zA-Z]|$)/g,
			function(s,m) { return m.toUpperCase(); }));
};

var titleCase = function(name) {
	return (name
		.toLowerCase()
		.replace(/(?:^|[^a-zA-Z]+)([a-zA-Z]|$)/g,
			function(s,m) { return m.toUpperCase(); }));
};
var makeGensyms = function() {
	var _used = {};
	var gs = function(hint) {
		var used;
		hint = hint || 'sym';
		if ((used = _used[hint]) === undefined) {
			_used[hint] = 1;
			return hint;
		} else {
			_used[hint] = used + 1;
			return hint + '_' + used;
		}
	};
	gs.reset = function() { _used = {}; };
	return gs;
};

var genSym = makeGensyms();

//hasher functions for memoize
var joinComma = function(items) { return Array.prototype.join.call(items, ','); };
var first = function(items) { return items[0]; };

//memoize assumes indirect recursion
var memoize = function(func, hasher) {
	hasher = (hasher !== undefined) ? hasher : joinComma;
	var memo = function() {
		var cache = memo.cache, args = hasher(arguments);
		if (cache[args] === undefined)
			cache[args] = memo.func.apply(this, arguments);
		return cache[args];
	}
	memo.func = func; //so we can replace the func
	memo.clearCache = function() { memo.cache = {}; };
	memo.cache = {};
	return memo;
};

// used for memoize when X[] = ... is used
//TODO: also need to be able to give this another dim to index over
// i.e. X[Y] to say this is indexed over Y
var indexed = function(func, hasher) {
	hasher = (hasher !== undefined) ? hasher : joinComma;
	var memo = function(i) { //function(i, ...rest)
		var rest = Array.prototype.slice.call(arguments, 1);
		var cache = memo.cache, args = hasher(rest);
		if (cache[args] === undefined)
			cache[args] = memo.func.apply(this, rest);
		//return list if i is undefined so we can do indexOf
		return (i !== undefined) ? memo.cache[args][i] : memo.cache[args];
	};
	memo.func = func; //so we can replace the function
	memo.clearCache = function() { memo.cache = {}; }
	memo.cache = {};
	return memo;
};



var benchmark = function(times, name, f) {
	console.time(name);
	for (; times > 0; times--) {
		f();
	}
	console.timeEnd(name);
};

/* NOTES

this['something with special characters'] is just as fast as this.something_without_special

//build functions like
ns[<head>] = memoize(new Function('a','b','return this[<otherhead>](a) + b;'))

*/

//Example

//Functions: note we assume sparse arrays and forEach only visits values in the array
var Sum = function(list) {
	var sum = 0;
	list.forEach(function(v,i) { if (v !== undefined) sum += v; });
	return sum;
};

var Head = function(list) {
	var head;
	list.some(function(v,i) { head = v; return true;});
	return head;
};

var Unique = function(list) {
	var included = {}, ret = [];
	list.forEach(function(v, i) {
		if (!included.hasOwnProperty(v)) {
			ret.push(v);
			included[v] = true;
		}
	});
	return ret;
};

// returns only defined values
var Values = function(list) {
	return list.filter(function() { return true; });
};

//Make macros that run at compile time
//First(Month) => #Month=0
//Last(Month) => #Month=length(Month[])-1
//Prev(Month) => #Month=#Month-1
//Next(Month) => #Month=#Month+1
//This(Month,offset) => #Month=#Month+offset

var compile = function(args, body, index) {
	if (index)
		return indexed(new Function(args, body));
	return memoize(new Function(args, body));
};

var category = function(body) {
	return indexed(new Function(body));
};

var Clay = new Namespace('Clay');

Clay['Month'] = category("return ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];");
//Clay['Month'].dimensions = [Clay['Month']];

Clay['Unit Sales'] = compile(['month', 'growth'], "return (this['Month'](month) === 'Jan') ? 5000 : this['Unit Sales'](month - 1, growth) * (1 + this['Growth'](growth));");
Clay['Growth'] = category("return [0.01,0.02,0.03,0.04,0.05];");
Clay['Price'] = new Number(55);
Clay['Unit Cost'] = new Number(25);
Clay['Fixed Costs'] = new Number(2000);
Clay['Revenue'] = compile(['month', 'growth'],"return this['Unit Sales'](month, growth) * this['Price'];");
Clay['COGS'] = compile(['month', 'growth'],"return this['Unit Sales'](month, growth) * this['Unit Cost'];");
Clay['EBIT'] = compile(['month', 'growth'],"return this['Revenue'](month, growth) - this['Fixed Costs'] - this['COGS'](month, growth);");
Clay['Debt'] = new Number(10000);
Clay['Interest Rate'] = new Number(0.08);
Clay['Tax Rate'] = new Number(0.3);
Clay['Interest'] = compile([],"return this['Debt'] * this['Interest Rate'] / 12");
Clay['EBT'] = compile(['month', 'growth'],"return this['EBIT'](month, growth) - this['Interest']()");
Clay['Tax'] = compile(['month', 'growth'],"return this['EBT'](month, growth) * this['Tax Rate']");
Clay['Net Income'] = compile(['month', 'growth'],"return this['EBT'](month, growth) - this['Tax'](month, growth)");

//Unit Sales[Month][Growth]
var test_x = Clay['Growth']().map(function(v, growth) {
	return Clay['Month']().map(function(v,month) {
		return Clay['Unit Sales'](month, growth); }); });

//Unit Sales[Month,Growth]
var test_y = (function() {
	var ret = [];
	Clay['Growth']().forEach(function(v, growth) {
		Clay['Month']().forEach(function(v, month) {
			ret.push(Clay['Unit Sales'](month, growth));
		});
	});
	return ret;
}());

var index = function(list) {
	return function(i) {
		if (i === undefined) return list;
		return list[i];
	};
};
/* this cannot work as you cannot override length on a function
var rowsC = function(n) {
	var cat = function(i) {
		if (i >= 0 && i < n) return i + 1;
		if (i === undefined) return cat;
	}
	cat.indexOf = function(i) {
		if (i > 0 && i <= n) return i - 1;
	}
	cat.forEach = function(f) {
		for(var i = 0; i < n; i++)
			f(i+1,i,cat);
	};
	cat.length = n;
	cat.map = function(f) {
		var i, cur, ret = [];
		for(var i = 0; i < n; i++) {
			if((cur = f(i+1,i,cat)) !== undefined)
				ret[i] = cur;
		}
		return ret;
	};
	return cat;
};*/

var rowsC = function(n) {
	var items = [], i = 0;
	while(i < n)
		items[i] = ++i;
	return index(items);
};

//Parallel arrays version
var Data = new Namespace('Data');
Data['State'] = index(['WA','WA','KS','KS','FL','FL','FL','FL']);
Data['Gender'] = index(['M','F','M','F','M','F','M','F']);
Data['City'] = index(['Seattle', 'Seattle', 'Lawrence', 'Lawrence', 'Miami', 'Miami', 'Orlando', 'Orlando']);
Data['Pop'] = index([2,23,4,345,546,2,1000,2000]);
Data['Data'] = rowsC(8); //cannot have a matrix of the same name as a namespace (so this is safe);

//Source(....) can actually be macro that expands at compile time to something else.
//Source(Src, ...)
//expands to Src.Src[] = source(...)

//assume this is the data you get back from source
data = [{State: 'WA', Gender:'M', City:'Seattle', Pop:2},
 {State: 'WA', Gender:'F', City:'Seattle', Pop:23},
 {State: 'KS', Gender:'M', City:'Lawrence', Pop:4},
 {State: 'KS', Gender:'F', City:'Lawrence', Pop:345},
 {State: 'FL', Gender:'M', City:'Miami', Pop:546},
 {State: 'FL', Gender:'F', City:'Miami', Pop:2},
 {State: 'FL', Gender:'M', City:'Orlando', Pop:1000},
 {State: 'FL', Gender:'F', City:'Orlando', Pop:2000}];

//Table (i.e. Row Key)
var Table = new Namespace('Table');
Table.Row = index(data);
Table['State'] = function(row) { return data[row]['State']; };
Table['Gender'] = function(row) { return data[row]['Gender']; };
Table['City'] = function(row) { return data[row]['City']; };
Table['Pop'] = function(row) { return data[row]['Pop']; };

//TODO: ast based table conversion/link

//NOTE :::: VERY IMPORTANT :::: when you are making a dimension you have head an package.

//Dense (given Key (and perhaps an Aggregate (default to Sum)))
//Assume given Key is ['State', 'Gender', 'City']
//TODO: Should really be called something like  pivot or tableToMatrix
var makeDense = function(ns, data, keys, aggregates) {
	var dense = {}, key = {}, val = {};
	keys.forEach(function(k) { key[k] = {}; dense[k] = []; });
	data.forEach(function(d) {
		var currentKey = keys.map(function(k) {
			var v = d[k], i = key[k][v];
			if (i === undefined) {
				//first time we have seen this key
				i = key[k][v] = dense[k].length;
				dense[k].push(v);
			}
			return i;
		}).join(',');
		for (var k in d) {
			if (!key.hasOwnProperty(k)) {
				if (!val.hasOwnProperty(k))
					val[k] = dense[k] = {};
				if (!dense[k].hasOwnProperty(currentKey))
					dense[k][currentKey] = [];
				dense[k][currentKey].push(d[k]);
			}
		}
	});
	//aggregate
	for(var k in val) {
		var agg = (aggregates !== undefined && aggregates[k] !== undefined) ? aggregates[k] : Sum;
		for (var ky in dense[k])
			dense[k][ky] = agg(dense[k][ky]);
		ns[k] = function(k) { 
			return function() { 
				return dense[k][joinComma(arguments)]; 
			}; 
		}(k);
	}
	keys.forEach(function(k) {
		ns[k] = index(dense[k]);
	});
};

var Dense = new Namespace('Dense');
makeDense(Dense, data, ['State', 'Gender', 'City']);

//return a sparse array
var slice = function(dims, func) {
	if (dims.length < 1) return [];
	var ret = [], i = 0, lengths, args, last = dims.length - 1, end = 1, cur, point;
	lengths = dims.map(function(dim) { return dim.length; });
	args = lengths.map(function() { return 0; }); //initial start values
	lengths.forEach(function(v) { end = end * v; });
	while(i < end) {
		if ((cur = func.apply(this, args)) !== undefined)
			ret[i] = cur;
		i += 1;
		args[last] += 1;
		point = last;
		while(point >= 0 && args[point] === lengths[point]) {
			args[point] = 0;
			point -= 1
			args[point] += 1;
		}
	}
	return ret;
};


//Sum(Data.Pop[Data.State=KS,Data.City=Lawrence, Data])
var test_z1 = Sum(Data['Data']().map(function(v, data) {
	if (Data['State'](data) == 'KS' && Data['City'](data) == 'Lawrence')
		return Data['Pop'](data);
}));

//Or
var test_z2 = Sum(slice([Data['Data']()], function(data) {
	if (Data['State'](data) == 'KS' && Data['City'](data) == 'Lawrence')
		return Data['Pop'](data);
}));

var test_head = Head(slice([Data['Data']()], function(data) {
	if (Data['City'](data) == 'Miami')
		return Data['State'](data);
}));

Clay['Gender'] = compile([],"return ['M', 'F']",true);

//TODO: this needs to be memoized and therefore callable.
// but that causes a problem with the compile of Growth
// do we make it Growth()[growth] or Growth(growth) with special memoization
// the latter seems more sensible.
// Or we can say that Growth[Growth] = ...
// State[] => State[State]
// [State] = Un... is function(state) {}
Clay['State'] = compile([],"return Unique(slice([Data['Data']], \
function(data) { return Data['State'][data]; }));", true);

//Syntax
//Slice [Y] is all the indexes of Y
// X[Y] is X mapped over [Y]
// X[] is shorthand for X[X] and assumes X is a synonym for a dimension

// X[Y] = (...) is valid an assumes that the list has the same dimension
// as [Y]
// X[Y][Z] = ((...)...) is also valid
// X[Y,Z] = (...) is not supported in the first version

//Jan01 < Month < Mar01 is all the elements of Month where that predicate
// is true

//Type specifier 
//head:typed 


//Really inefficient first try...
//Can make this fast with indexes on Data['State']
// and Data['Gender'] and zigzag matching
Clay['Population'] = function(state, gender) {
	return Sum(slice([Data['Data']()], function(data) {
		if (Data['State'](data)  == Clay['State'](state) &&
			Data['Gender'](data) == Clay['Gender'](gender))
			return Data['Pop'](data);
	}));
};


slice([Clay['Growth'](), Clay['Month']()],
	function(growth, month) {
		if (month < 5) return Clay['Net Income'](month, growth);
	});

//NOTE: Net Income[Month=Jan] != Net Income[Month==Jan]
// Net Income[Month==Jan] is
var test_doubleEq = function(month, growth) {
	return (this['Month'](month) == 'Jan') ? this['Net Income'](month, growth)
		: undefined;
}.bind(Clay);

// Net Income[Month=Jan] is
var test_singleEq = function(growth) {
	return this['Net Income'](this['Month']().indexOf('Jan'),growth);
}.bind(Clay);


//Actual list
//CollectionRates = [40%, 50%, 10%, 0%, 0%]
//Collections = Convolve(#Month, Sales[Month], CollectionRates)


//test_f() !== test_f() ... so it runs every time.
var test_f = function() {
	return ['a','b','c'];
};
var test_fM = memoize(test_f);
//but test_fM() === test_fM()

//Probably need Growth()


//Model ideas


</script>
</body>
</html>
